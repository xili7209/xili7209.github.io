<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JMM</title>
    <link href="/2021/11/01/JMM/"/>
    <url>/2021/11/01/JMM/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><h4 id="从堆栈说起"><a href="#从堆栈说起" class="headerlink" title="从堆栈说起"></a>从堆栈说起</h4><p>局部变量都在stack上，线程只能访问自己的堆栈<br>基本类型的所有局部变量(boolean，byte，short，char，int，long，float，double)完全存储在线程堆栈中，因此对其他线程不可见。 一个线程可以将一个基本类型变量的副本传递给另一个线程，但它不能共享原始局部变量本身</p><p>堆包含了在Java应用程序中创建的所有对象，无论创建该对象的线程是什么。 这包括基本类型的包装类(例如Byte，Integer，Long等)。 无论是创建对象并将其分配给局部变量，还是创建为另一个对象的成员变量，该对象仍然存储在堆上。引用(局部变量)存储在线程堆栈中，但是对象本身存储在堆(Heap)上。对象相关的成员变量以及对象本身都在heap上（静态类变量也与类定义一起存储在堆上）</p><h4 id="线程栈如何访问堆上对象"><a href="#线程栈如何访问堆上对象" class="headerlink" title="线程栈如何访问堆上对象"></a>线程栈如何访问堆上对象</h4><p>对象引用的线程都可以访问堆上的对象。 当一个线程有权访问一个对象时，它也可以访问该对象的成员变量。 如果两个线程同时在同一个对象上调用一个方法，它们都可以访问该对象的成员变量，但每个线程都有自己的局部变量副本</p><p>两个局部变量指向堆上的共享对象，他们有不同的引用但指向相同的对象</p><h4 id="example-amp-explanation"><a href="#example-amp-explanation" class="headerlink" title="example &amp; explanation"></a>example &amp; explanation</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> class MyRunnable implements <span class="hljs-title">Runnable</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        methodOne();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodOne</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> localVariable1 = <span class="hljs-number">45</span>;<br><br>        MySharedObject localVariable2 =<br>            MySharedObject.sharedInstance;<br><br>        <span class="hljs-comment">//... do more with local variables.</span><br><br>        methodTwo();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodTwo</span><span class="hljs-params">()</span> </span>&#123;<br>        Integer localVariable1 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">99</span>);<br><br>        <span class="hljs-comment">//... do more with local variable.</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySharedObject</span> </span>&#123;<br><br>    <span class="hljs-comment">//static variable pointing to instance of MySharedObject</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> MySharedObject sharedInstance =<br>        <span class="hljs-keyword">new</span> MySharedObject();<br><br><br>    <span class="hljs-comment">//member variables pointing to two objects on the heap</span><br><br>    <span class="hljs-keyword">public</span> Integer object2 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">22</span>);<br>    <span class="hljs-keyword">public</span> Integer object4 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">44</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> member1 = <span class="hljs-number">12345</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> member1 = <span class="hljs-number">67890</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解析</strong><br>如果两个线程正在执行run()方法，run()方法调用methodOne()，methodOne()调用methodTwo()<br>methodOne：一个局部基本类型变量(类型为int的localVariable1)和一个局部变量，它是一个对象引用(localVariable2)<br>执行methodOne()的每个线程将在各自的线程堆栈上创建自己的localVariable1和localVariable2副本。 localVariable1变量将完全相互分离，只存在于每个线程的线程堆栈中。 一个线程无法看到另一个线程对其localVariable1副本所做的更改</p><p>执行methodOne()的每个线程也将创建自己的localVariable2副本。 但是，localVariable2的两个不同副本最终都指向堆上的同一个对象。 代码将localVariable2设置为指向静态变量引用的对象。 静态变量只有一个副本，此副本存储在堆上。 因此，localVariable2的两个副本最终都指向静态变量指向的MySharedObject的同一个实例。 MySharedObject实例也存储在堆上</p><p>注意MySharedObject类还包含两个成员变量。 成员变量本身与对象一起存储在堆上。 两个成员变量指向另外两个Integer对象。 这些Integer对象对应于上图中的Object 2和Object 4<br>法将localVariable1引用设置为指向新的Integer实例。 localVariable1引用将存储在执行methodTwo()的每个线程的一个副本中。 实例化的两个Integer对象将存储在堆上，但由于该方法每次执行该方法时都会创建一个新的Integer对象</p><p>MySharedObject的两个long及Integer都在heap上</p><h3 id="JMM与硬件内存结构关系"><a href="#JMM与硬件内存结构关系" class="headerlink" title="JMM与硬件内存结构关系"></a>JMM与硬件内存结构关系</h3><p><img src="https://user-images.githubusercontent.com/58756074/139648172-af79a044-ea82-43e4-890f-d969c7e888d5.png" alt="JMM和硬件"><br>JMM和硬件内存框架不同，硬件分为CPU寄存器，CPU三级缓存，主存。硬件是不分stack heap的，所以堆栈的消息可能存在于硬件的任意位置</p><h4 id="Visibility"><a href="#Visibility" class="headerlink" title="Visibility"></a>Visibility</h4><p>如果多个线程共享一个对象而没有正确使用volatile声明或同步，则一个线程对共享对象的更新可能对其他线程不可见（线程间的通信得依赖主存），这涉及MESI和bus snooping的操作系统原理简单来说是因为可能各个处理器中的缓存没有及时被更新，及修改没被写入主存，导致其他缓存无法获取及时消息</p><h4 id="Race-Condition"><a href="#Race-Condition" class="headerlink" title="Race Condition"></a>Race Condition</h4><p>如果两个或多个线程共享一个对象，并且多个线程更新该共享对象中的变量，则可能会出现竞态</p><p>要解决此问题，您可以使用Java synchronized块。 同步块保证在任何给定时间只有一个线程可以进入代码的给定关键部分。 同步块还保证在同步块内访问的所有变量都将从主存储器中读入，当线程退出同步块时，所有更新的变量将再次刷新回主存储器，无论变量是不是声明为volatile</p><p>More info: <a href="https://www.pdai.tech/md/java/jvm/java-jvm-x-introduce.html">JMM Introduction</a></p><h3 id="TBA"><a href="#TBA" class="headerlink" title="TBA"></a>TBA</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">N/A<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="TBA-1"><a href="#TBA-1" class="headerlink" title="TBA"></a>TBA</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">N/A<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC经典案例</title>
    <link href="/2021/11/01/JUC%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B/"/>
    <url>/2021/11/01/JUC%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">emptyBuffer （N）<br>fullBuffer (0)<br>mutex (lock) (1)<br>producer:<br>    p(emptyBuffer)  //-1<br>    P(mutex)    //-1<br>    write<br>    v(mutex)  //+1<br>    V(fullBuffer)  //+1<br><br>consumer:<br>    p(fullBuffer)  //-1<br>    P(mutex)    //-1<br>    <span class="hljs-built_in">read</span><br>    v(mutex)  //+1<br>    V(emptyBuffer)  //+1<br></code></pre></td></tr></table></figure><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerConsumerTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Buffer c = <span class="hljs-keyword">new</span> Buffer();<br>        Producer p1 = <span class="hljs-keyword">new</span> Producer(c, <span class="hljs-number">1</span>);<br>        Consumer c1 = <span class="hljs-keyword">new</span> Consumer(c, <span class="hljs-number">1</span>);<br>        p1.start();<br>        c1.start();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Buffer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (queue.size()==<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            &#125;<br>        &#125;<br>        notifyAll();<br>        <span class="hljs-keyword">return</span> queue.poll();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (queue.size() == <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            &#125;<br>        &#125;<br>        queue.add(value);<br>        notifyAll();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Buffer buffer;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(Buffer c, <span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        buffer = c;<br>        <span class="hljs-keyword">this</span>.number = number;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            value = buffer.get();<br>            System.out.println(<span class="hljs-string">&quot;消费者 #&quot;</span> + <span class="hljs-keyword">this</span>.number+ <span class="hljs-string">&quot; got: &quot;</span> + value);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Buffer buffer;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Producer</span><span class="hljs-params">(Buffer c, <span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        buffer = c;<br>        <span class="hljs-keyword">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            buffer.put(i);<br>            System.out.println(<span class="hljs-string">&quot;生产者 #&quot;</span> + <span class="hljs-keyword">this</span>.number + <span class="hljs-string">&quot; put: &quot;</span> + i);<br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep((<span class="hljs-keyword">int</span>)(Math.random() * <span class="hljs-number">100</span>));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerConsumerLockTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        LockBuffer c = <span class="hljs-keyword">new</span> LockBuffer();<br>        LockProducer p1 = <span class="hljs-keyword">new</span> LockProducer(c, <span class="hljs-number">1</span>);<br>        LockConsumer c1 = <span class="hljs-keyword">new</span> LockConsumer(c, <span class="hljs-number">1</span>);<br>        p1.start();<br>        c1.start();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockBuffer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition condition = lock.newCondition();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">while</span> (queue.size()==<span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    condition.await();<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br>            &#125;<br>            res = queue.poll();<br>            condition.signal();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == <span class="hljs-number">10</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    condition.await();<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br>            &#125;<br>            queue.add(value);<br>            condition.signal();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockConsumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> LockBuffer buffer;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LockConsumer</span><span class="hljs-params">(LockBuffer c, <span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        buffer = c;<br>        <span class="hljs-keyword">this</span>.number = number;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            value = buffer.get();<br>            System.out.println(<span class="hljs-string">&quot;消费者 #&quot;</span> + <span class="hljs-keyword">this</span>.number+ <span class="hljs-string">&quot; got: &quot;</span> + value);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockProducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> LockBuffer buffer;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LockProducer</span><span class="hljs-params">(LockBuffer c, <span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        buffer = c;<br>        <span class="hljs-keyword">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            buffer.put(i);<br>            System.out.println(<span class="hljs-string">&quot;生产者 #&quot;</span> + <span class="hljs-keyword">this</span>.number + <span class="hljs-string">&quot; put: &quot;</span> + i);<br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep((<span class="hljs-keyword">int</span>)(Math.random() * <span class="hljs-number">100</span>));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程交替打印-LeetCode-1114-1115-1116"><a href="#线程交替打印-LeetCode-1114-1115-1116" class="headerlink" title="线程交替打印 (LeetCode 1114,1115,1116)"></a>线程交替打印 (LeetCode 1114,1115,1116)</h3><h4 id="print-AB-yield"><a href="#print-AB-yield" class="headerlink" title="print AB(yield)"></a>print AB(yield)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">printAB</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Printer printer = <span class="hljs-keyword">new</span> Printer();<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintA(printer));<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintB(printer));<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Printer</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> first = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printA</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;)&#123;<br>            <span class="hljs-keyword">if</span>(first)&#123;<br>                System.out.println(<span class="hljs-string">&quot;thread&quot;</span> + Thread.currentThread()+ <span class="hljs-string">&quot;print A&quot;</span>);<br>                i++;<br>                first= <span class="hljs-keyword">false</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                Thread.yield();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printB</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;)&#123;<br>            <span class="hljs-keyword">if</span>(!first)&#123;<br>                System.out.println(<span class="hljs-string">&quot;thread&quot;</span> + Thread.currentThread()+ <span class="hljs-string">&quot;print B&quot;</span>);<br>                i++;<br>                first= <span class="hljs-keyword">true</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                Thread.yield();<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Printer printer;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrintA</span><span class="hljs-params">(Printer printer)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.printer = printer;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        printer.printA();<br><br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Printer printer;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrintB</span><span class="hljs-params">(Printer printer)</span></span>&#123;<br><br>        <span class="hljs-keyword">this</span>.printer = printer;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        printer.printB();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="print0-10-yield"><a href="#print0-10-yield" class="headerlink" title="print0-10(yield)"></a>print0-10(yield)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">printToTen</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NumberPrinter printer = <span class="hljs-keyword">new</span> NumberPrinter();<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintEven(printer));<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintOdd(printer));<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberPrinter</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> first = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printEven</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">10</span>;)&#123;<br>            <span class="hljs-keyword">if</span>(first)&#123;<br>                System.out.println(<span class="hljs-string">&quot;thread&quot;</span> + Thread.currentThread()+ <span class="hljs-string">&quot;print&quot;</span>+i);<br>                i++;<br>                first= <span class="hljs-keyword">false</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                Thread.yield();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printOdd</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">10</span>;)&#123;<br>            <span class="hljs-keyword">if</span>(!first)&#123;<br>                System.out.println(<span class="hljs-string">&quot;thread&quot;</span> + Thread.currentThread()+ <span class="hljs-string">&quot;print&quot;</span>+i);<br>                i++;<br>                first= <span class="hljs-keyword">true</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                Thread.yield();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintEven</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> NumberPrinter printer;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrintEven</span><span class="hljs-params">(NumberPrinter printer)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.printer = printer;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        printer.printEven();<br><br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintOdd</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> NumberPrinter printer;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrintOdd</span><span class="hljs-params">(NumberPrinter printer)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.printer = printer;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        printer.printOdd();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="哲学家就餐"><a href="#哲学家就餐" class="headerlink" title="哲学家就餐"></a>哲学家就餐</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">N/A<br></code></pre></td></tr></table></figure><h3 id="TBA"><a href="#TBA" class="headerlink" title="TBA"></a>TBA</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">N/A<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lock Support</title>
    <link href="/2021/10/31/Lock-Support/"/>
    <url>/2021/10/31/Lock-Support/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="为什么LockSupport也是核心基础类-AQS框架借助于两个类：Unsafe-提供CAS操作-和LockSupport-提供park-unpark操作"><a href="#为什么LockSupport也是核心基础类-AQS框架借助于两个类：Unsafe-提供CAS操作-和LockSupport-提供park-unpark操作" class="headerlink" title="为什么LockSupport也是核心基础类? AQS框架借助于两个类：Unsafe(提供CAS操作)和LockSupport(提供park/unpark操作)"></a>为什么LockSupport也是核心基础类? AQS框架借助于两个类：Unsafe(提供CAS操作)和LockSupport(提供park/unpark操作)</h3><p>LockSupport底层用的也是unsafe,且constructor为private无法实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Unsafe</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">park</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isAbsolute, <span class="hljs-keyword">long</span> time)</span></span>; <span class="hljs-comment">// time=0 无限等待until unpark   当time为绝对时间时，isAbsolute为true，否则，isAbsolute为false</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unpark</span><span class="hljs-params">(Thread thread)</span></span>;<br><span class="hljs-comment">//LockSupport</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">park</span><span class="hljs-params">()</span>；</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">park</span><span class="hljs-params">(Object blocker)</span>；</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parkNanos</span><span class="hljs-params">(Object blocker, <span class="hljs-keyword">long</span> nanos)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parkUntil</span><span class="hljs-params">(Object blocker, <span class="hljs-keyword">long</span> deadline)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unpark</span><span class="hljs-params">(Thread thread)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="写出分别通过wait-notify和LockSupport的park-unpark实现同步"><a href="#写出分别通过wait-notify和LockSupport的park-unpark实现同步" class="headerlink" title="写出分别通过wait/notify和LockSupport的park/unpark实现同步?"></a>写出分别通过wait/notify和LockSupport的park/unpark实现同步?</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;before notify&quot;</span>);            <br>            notify();<br>            System.out.println(<span class="hljs-string">&quot;after notify&quot;</span>);    <br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitAndNotifyDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        MyThread myThread = <span class="hljs-keyword">new</span> MyThread();            <br>        <span class="hljs-keyword">synchronized</span> (myThread) &#123;<br>            <span class="hljs-keyword">try</span> &#123;        <br>                myThread.start();<br>                <span class="hljs-comment">// 主线程睡眠3s</span><br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>                System.out.println(<span class="hljs-string">&quot;before wait&quot;</span>);<br>                <span class="hljs-comment">// 阻塞主线程</span><br>                myThread.wait();<br>                System.out.println(<span class="hljs-string">&quot;after wait&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;            <br>        &#125;        <br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">before wait</span><br><span class="hljs-comment">before notify</span><br><span class="hljs-comment">after notify</span><br><span class="hljs-comment">after wait</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Object object;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(Object object)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.object = object;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;before unpark&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">// 获取blocker</span><br>        System.out.println(<span class="hljs-string">&quot;Blocker info &quot;</span> + LockSupport.getBlocker((Thread) object));<br>        <span class="hljs-comment">// 释放许可</span><br>        LockSupport.unpark((Thread) object);<br>        <span class="hljs-comment">// 休眠500ms，保证先执行park中的setBlocker(t, null);</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">500</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">// 再次获取blocker</span><br>        System.out.println(<span class="hljs-string">&quot;Blocker info &quot;</span> + LockSupport.getBlocker((Thread) object));<br><br>        System.out.println(<span class="hljs-string">&quot;after unpark&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MyThread myThread = <span class="hljs-keyword">new</span> MyThread(Thread.currentThread());<br>        myThread.start();<br>        System.out.println(<span class="hljs-string">&quot;before park&quot;</span>);<br>        <span class="hljs-comment">// 获取许可</span><br>        LockSupport.park(<span class="hljs-string">&quot;ParkAndUnparkDemo&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;after park&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">before park</span><br><span class="hljs-comment">before unpark</span><br><span class="hljs-comment">Blocker info ParkAndUnparkDemo</span><br><span class="hljs-comment">after park</span><br><span class="hljs-comment">Blocker info null</span><br><span class="hljs-comment">after unpark</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>原理</strong>：线程有一个计数器，初始值为0，如果这个值为0，就将线程挂起，状态改为 WAITING。如果这个值为1，则将这个值改为0，其余的什么都不做<br>unpark就是将这个值改为1</p><h3 id="LockSupport-park-会释放锁资源吗-那么Condition-await-呢"><a href="#LockSupport-park-会释放锁资源吗-那么Condition-await-呢" class="headerlink" title="LockSupport.park()会释放锁资源吗? 那么Condition.await()呢?"></a>LockSupport.park()会释放锁资源吗? 那么Condition.await()呢?</h3><p><strong>Ans：</strong>不会，它只负责阻塞当前线程，释放锁资源实际上是在Condition的await()方法中实现的</p><h3 id="Thread-sleep-、Object-wait-、Condition-await-、LockSupport-park-的区别-重点"><a href="#Thread-sleep-、Object-wait-、Condition-await-、LockSupport-park-的区别-重点" class="headerlink" title="Thread.sleep()、Object.wait()、Condition.await()、LockSupport.park()的区别? 重点"></a>Thread.sleep()、Object.wait()、Condition.await()、LockSupport.park()的区别? 重点</h3><h4 id="Thread-sleep-和Object-wait-的区别"><a href="#Thread-sleep-和Object-wait-的区别" class="headerlink" title="Thread.sleep()和Object.wait()的区别"></a>Thread.sleep()和Object.wait()的区别</h4><ul><li>Thread.sleep()不会释放占有的锁，Object.wait()会释放占有的锁；</li><li>Thread.sleep()必须传入时间，Object.wait()可传可不传，不传表示一直阻塞下去</li><li>Thread.sleep()到时间了会自动唤醒，然后继续执行</li><li>Object.wait()不带时间的，需要另一个线程使用Object.notify()唤醒</li><li>Object.wait()带时间的，假如没有被notify，到时间了会自动唤醒，这时又分好两种情况，一是立即获取到了锁，线程自然会继续执行；二是没有立即获取锁，线程进入同步队列（Sync Queue）等待获取锁</li></ul><p><strong>Thread.sleep()、Object.wait()最大区别就是Thread.sleep()不会释放锁资源，Object.wait()会释放锁资源</strong></p><h4 id="Thread-sleep-和Condition-await-的区别"><a href="#Thread-sleep-和Condition-await-的区别" class="headerlink" title="Thread.sleep()和Condition.await()的区别"></a>Thread.sleep()和Condition.await()的区别</h4><p>Object.wait()和Condition.await()的原理是基本一致的，不同的是Condition.await()底层是调用LockSupport.park()来实现阻塞当前线程的<br>Condition.await()在阻塞当前线程之前还干了两件事，一是把当前线程添加到条件队列（conditon queue）中，二是“完全”释放锁，也就是让state状态变量变为0，然后才是调用LockSupport.park()阻塞当前线程</p><h4 id="Thread-sleep-和LockSupport-park-的区别"><a href="#Thread-sleep-和LockSupport-park-的区别" class="headerlink" title="Thread.sleep()和LockSupport.park()的区别"></a>Thread.sleep()和LockSupport.park()的区别</h4><ul><li>从功能上来说，Thread.sleep()和LockSupport.park()方法类似，都是阻塞当前线程的执行，且都不会释放当前线程占有的锁资源</li><li>Thread.sleep()没法从外部唤醒，只能自己醒过来</li><li>LockSupport.park()方法可以被另一个线程调用LockSupport.unpark()方法唤醒</li><li>Thread.sleep()方法声明上抛出（throws）了<strong>InterruptedException中断异常</strong>，所以调用者需要捕获这个异常或者再抛出</li><li>LockSupport.park()方法不需要捕获中断异常</li><li>Thread.sleep()本身就是一个native方法  （native 后的函数的实现不是用java写的都是操作系统实现的，<br>java只能调用）</li><li>LockSupport.park()底层是调用的Unsafe的native方法</li></ul><h4 id="Object-wait-和LockSupport-park-的区别"><a href="#Object-wait-和LockSupport-park-的区别" class="headerlink" title="Object.wait()和LockSupport.park()的区别"></a>Object.wait()和LockSupport.park()的区别</h4><ul><li>Object.wait()方法需要在synchronized块中执行</li><li>LockSupport.park()可以在任意地方执行</li><li>Object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出</li><li>LockSupport.park()不需要捕获中断异常</li><li>Object.wait()不带超时的，需要另一个线程执行notify()来唤醒，但不一定继续执行后续内容</li><li>LockSupport.park()不带超时的，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容</li><li>如果在wait()之前执行了notify()会怎样? 抛出IllegalMonitorStateException异常</li><li>如果在park()之前执行了unpark()会怎样? 线程不会被阻塞，直接跳过park()，继续执行后续内容<br>park()/unpark()底层的原理是“二元信号量”，你可以把它相像成只有一个许可证的Semaphore，只不过这个信号量在重复执行unpark()的时候也不会再增加许可证，最多只有一个许可证</li></ul><h3 id="如果在wait-之前执行了notify-会怎样"><a href="#如果在wait-之前执行了notify-会怎样" class="headerlink" title="如果在wait()之前执行了notify()会怎样?"></a>如果在wait()之前执行了notify()会怎样?</h3><p><strong>Ans:</strong> 使用wait/notify实现同步时，必须先调用wait，后调用notify，如果先调用notify，再调用wait，将起不了作用</p><h3 id="如果在park-之前执行了unpark-会怎样"><a href="#如果在park-之前执行了unpark-会怎样" class="headerlink" title="如果在park()之前执行了unpark()会怎样?"></a>如果在park()之前执行了unpark()会怎样?</h3><p><strong>Ans:</strong> 可以看到，在先调用unpark，再调用park时，仍能够正确实现同步，不会造成由wait/notify调用顺序不当所引起的阻塞。因此park/unpark相比wait/notify更加的灵活</p><h3 id="其他线程中断后被park的主线程会怎么样"><a href="#其他线程中断后被park的主线程会怎么样" class="headerlink" title="其他线程中断后被park的主线程会怎么样"></a>其他线程中断后被park的主线程会怎么样</h3><p><strong>Ans：</strong> 在主线程调用park阻塞后，在myThread线程中发出了中断信号，此时主线程会继续运行，也就是说明此时interrupt起到的作用与unpark一样</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Thread</title>
    <link href="/2021/10/29/Java-Thread/"/>
    <url>/2021/10/29/Java-Thread/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="线程有哪几种状态-分别说明从一种状态到另一种状态转变有哪些方式"><a href="#线程有哪几种状态-分别说明从一种状态到另一种状态转变有哪些方式" class="headerlink" title="线程有哪几种状态? 分别说明从一种状态到另一种状态转变有哪些方式?"></a>线程有哪几种状态? 分别说明从一种状态到另一种状态转变有哪些方式?</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">State</span> </span>&#123;<br><br>    NEW, <span class="hljs-comment">//创建后尚未启动 thread.init</span><br><br>    RUNNABLE, <span class="hljs-comment">//可能正在运行，也可能正在等待 CPU 时间片包含Running和Ready thread.start()</span><br><br>    BLOCKED, <span class="hljs-comment">//等待获取一个排它锁，如果其线程释放了锁就会结束此状态</span><br><br>    WAITING, <span class="hljs-comment">//等待其它线程显式地唤醒，否则不会被分配 CPU 时间片 </span><br><br>    TIMED_WAITING, <span class="hljs-comment">//无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒 Thread.sleep()</span><br><br>    TERMINATED; <span class="hljs-comment">//当一个线程执行完毕（或者调用已经不建议的 stop 方法）</span><br><br>    <span class="hljs-comment">//waiting有点主动的意思，block多半是因为资源分配问题（条件不满足）被挂起</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/58756074/139376152-e613f09b-8675-439d-b1f2-4d2e7ce9e674.png" alt="线程状态"><br><img src="https://user-images.githubusercontent.com/58756074/139382615-392d4fb0-1602-4173-a1da-4dd2904dd43c.png" alt="线程状态转换API"></p><p><strong>wait/notify</strong>：</p><ol><li>释放lock（必须先获得lock）</li><li>状态变成waiting</li><li>线程加入lock对象等待队列<br>什么时候这个线程被唤醒，从等待队列中移出，并从 WAITING 状态返回 RUNNABLE 状态呢？ 必须由另一个线程，调用同一个对象的 notify/notifyAll 方法<br>Note：正常取锁失败的是加入同步队列（等待取锁blocking），wait加入的是等待队列</li></ol><p><strong>join</strong>:<br>当执行到 t.join() 的时候，主线程会变成 WAITING 状态，直到线程 t 执行完毕，主线程才会变回 RUNNABLE 状态，继续往下执行。看起来，就像是主线程执行过程中，另一个线程插队加入（join），而且要等到其结束后主线程才继续<br>线程 t 结束后，由 jvm 自动调用 t.notifyAll()</p><p><strong>Park&amp;Unpark</strong>：<br>一个线程调用<code>LockSupport.park()</code>该线程状态会从 RUNNABLE 变成 WAITING,另一个线程调用<code>LockSupport.unpark(Thread 刚刚的线程)</code>刚刚的线程会从 WAITING 回到 RUNNABLE但从线程状态流转来看，与 wait 和 notify 相同</p><ol><li>park 和 unpark 无需事先获取锁，或者说跟锁压根无关</li><li>没有什么等待队列一说，unpark 会精准唤醒某一个确定的线程</li><li>park 和 unpark 没有顺序要求，可以先调用 unpark</li></ol><p>线程有一个计数器，初始值为0，如果这个值为0，就将线程挂起，状态改为 WAITING。如果这个值为1，则将这个值改为0，其余的什么都不做<br>unpark就是将这个值改为1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">LockSupport.unpark(Thread.currentThread()); // 1<br>LockSupport.park(); // 0<br>System.out.println(&quot;可以运行到这&quot;);<br>// 例子2<br>LockSupport.unpark(Thread.currentThread()); // 1<br>LockSupport.unpark(Thread.currentThread()); // 1<br>LockSupport.park(); // 0<br>System.out.println(&quot;可以运行到这&quot;);<br>// 例子3<br>LockSupport.unpark(Thread.currentThread()); // 1<br>LockSupport.unpark(Thread.currentThread()); // 1<br>LockSupport.park(); // 0<br>LockSupport.park(); // WAITING<br>System.out.println(&quot;不可以运行到这&quot;);<br></code></pre></td></tr></table></figure><p>jdk的lock是基于 AQS 的，而 AQS 的底层，是用 park 和 unpark 来挂起和唤醒线程，所以应该是变为 WAITING 或 TIMED_WAITING 状态</p><p><strong>阻塞IO方法，thread处于什么状态？</strong> runnable但实际上这个线程是得不到运行权的，因为在操作系统层面处于阻塞态，需要等到 IO 就绪，才能变为就绪态</p><h3 id="通常线程有哪几种使用方式"><a href="#通常线程有哪几种使用方式" class="headerlink" title="通常线程有哪几种使用方式"></a>通常线程有哪几种使用方式</h3><ul><li>实现 Runnable 接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    MyRunnable instance = <span class="hljs-keyword">new</span> MyRunnable();<br>    Thread thread = <span class="hljs-keyword">new</span> Thread(instance);<span class="hljs-comment">//lambda也行</span><br>    thread.start();<br>&#125;<br></code></pre></td></tr></table></figure></li><li>实现 Runnable 接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>    MyCallable mc = <span class="hljs-keyword">new</span> MyCallable();<br>    FutureTask&lt;Integer&gt; ft = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(mc);<br>    Thread thread = <span class="hljs-keyword">new</span> Thread(ft);<br>    thread.start();<br>    System.out.println(ft.get());<br>&#125;<br></code></pre></td></tr></table></figure></li><li>继承 Thread 类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    MyThread mt = <span class="hljs-keyword">new</span> MyThread();<br>    mt.start();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><em>start vs thread</em>*:用start()来启动线程，真正实现了多线程，就算出现start()方法也是继续执行下面的代码而不需等待run()体代码执行完</li></ul><ul><li><p>通过调用Thread类的 start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法 run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止</p></li><li><p>run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，没有达到多线程的目的</p></li></ul><p><strong>实现接口 VS 继承 Thread</strong><br>实现接口更好</p><ul><li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口</li><li>类可能只要求可执行就行，继承整个 Thread 类开销过大</li></ul><h3 id="基础线程机制有哪些"><a href="#基础线程机制有哪些" class="headerlink" title="基础线程机制有哪些"></a>基础线程机制有哪些</h3><ul><li>Executor管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作<ul><li>CachedThreadPool: 一个任务创建一个线程</li><li>FixedThreadPool: 所有任务只能使用固定大小的线程</li><li>SingleThreadExecutor: 相当于大小为 1 的 FixedThreadPool</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ExecutorService executorService = Executors.newCachedThreadPool();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        executorService.execute(<span class="hljs-keyword">new</span> MyRunnable());<br>    &#125;<br>    executorService.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Daemon守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分，当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyRunnable());<br>    thread.setDaemon(<span class="hljs-keyword">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>sleep</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">3000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>yield（）调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行，当然这只是建议</p></li></ul><h3 id="线程的中断方式有哪些"><a href="#线程的中断方式有哪些" class="headerlink" title="线程的中断方式有哪些"></a>线程的中断方式有哪些</h3><ul><li><p>InterruptedException<br>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞</p></li><li><p>interrupted()<br>通过thread的interrupted（）标记位实现中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterruptExample</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (!interrupted()) &#123;<br>                <span class="hljs-comment">// ..</span><br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;Thread end&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread thread2 = <span class="hljs-keyword">new</span> MyThread2();<br>    thread2.start();<br>    thread2.interrupt();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>executor中断<br>调用 Executor 的 shutdown()（类似socket中shutdown优雅关闭） 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ExecutorService executorService = Executors.newCachedThreadPool();<br>    executorService.execute(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>            System.out.println(<span class="hljs-string">&quot;Thread run&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;);<br>    executorService.shutdownNow();<br>    System.out.println(<span class="hljs-string">&quot;Main run&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;<br>    <span class="hljs-comment">// ..</span><br>&#125;);<br>future.cancel(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="线程的互斥同步方式有哪些-如何比较和选择"><a href="#线程的互斥同步方式有哪些-如何比较和选择" class="headerlink" title="线程的互斥同步方式有哪些? 如何比较和选择"></a>线程的互斥同步方式有哪些? 如何比较和选择</h3><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><ol><li><p>同步一个代码块，它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedExample</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SynchronizedExample e1 = <span class="hljs-keyword">new</span> SynchronizedExample();<br>    ExecutorService executorService = Executors.newCachedThreadPool();<br>    executorService.execute(() -&gt; e1.func1());<br>    executorService.execute(() -&gt; e1.func1());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>同步一个方法，它和同步代码块一样，作用于同一个对象</p></li><li><p>同步一个类作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedExample</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (SynchronizedExample.class) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SynchronizedExample e1 = <span class="hljs-keyword">new</span> SynchronizedExample();<br>    SynchronizedExample e2 = <span class="hljs-keyword">new</span> SynchronizedExample();<br>    ExecutorService executorService = Executors.newCachedThreadPool();<br>    executorService.execute(() -&gt; e1.func2());<br>    executorService.execute(() -&gt; e2.func2());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>同步一个静态方法和同步类一样</p></li></ol><h4 id="ReentrantLock（java-util-concurrent-J-U-C-）"><a href="#ReentrantLock（java-util-concurrent-J-U-C-）" class="headerlink" title="ReentrantLock（java.util.concurrent(J.U.C)）"></a>ReentrantLock（java.util.concurrent(J.U.C)）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockExample</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock(); <span class="hljs-comment">// 确保释放锁，从而避免发生死锁。</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    LockExample lockExample = <span class="hljs-keyword">new</span> LockExample();<br>    ExecutorService executorService = Executors.newCachedThreadPool();<br>    executorService.execute(() -&gt; lockExample.func());<br>    executorService.execute(() -&gt; lockExample.func());<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>比较</strong></p><ol><li><p>锁的实现synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的</p></li><li><p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同</p></li><li><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock 可中断，而 synchronized 不行</p></li><li><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized 中的锁是非公平的（同时唤醒竞争），ReentrantLock 默认情况下也是非公平的，但是也可以是公平的</p></li><li><p>一个 ReentrantLock 可以同时绑定多个 Condition 对象</p></li></ol><p><strong>使用选择</strong><br>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放</p><h3 id="线程之间有哪些协作方式"><a href="#线程之间有哪些协作方式" class="headerlink" title="线程之间有哪些协作方式"></a>线程之间有哪些协作方式</h3><ol><li><p>join在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束</p></li><li><p>wait() notify() notifyAll()<br>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程<br>它们都属于 Object 的一部分，而不属于 Thread，只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateExeception</p></li></ol><p><strong>wait，sleep</strong>：wait属于object，而sleep是thread静态方法，wait会释放锁，sleep不会</p><ol start="3"><li>await() signal() signalAll()<br>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AwaitSignalExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-keyword">private</span> Condition condition = lock.newCondition();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;before&quot;</span>);<br>            condition.signalAll();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            condition.await();<br>            System.out.println(<span class="hljs-string">&quot;after&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ExecutorService executorService = Executors.newCachedThreadPool();<br>    AwaitSignalExample example = <span class="hljs-keyword">new</span> AwaitSignalExample();<br>    executorService.execute(() -&gt; example.after());<br>    executorService.execute(() -&gt; example.before());<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Concurrency</title>
    <link href="/2021/10/29/Java-Concurrency/"/>
    <url>/2021/10/29/Java-Concurrency/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="多线程的出现是要解决什么问题的"><a href="#多线程的出现是要解决什么问题的" class="headerlink" title="多线程的出现是要解决什么问题的"></a>多线程的出现是要解决什么问题的</h3><p>比进程颗粒度更小的执行单位，进程负责提供资源，同一进程下的线程可以共享资源无需像进程切换那样繁重</p><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="线程不安全是指什么-举例说明"><a href="#线程不安全是指什么-举例说明" class="headerlink" title="线程不安全是指什么? 举例说明"></a>线程不安全是指什么? 举例说明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadUnsafeExample</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>        cnt++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadSize = <span class="hljs-number">1000</span>;<br>    ThreadUnsafeExample example = <span class="hljs-keyword">new</span> ThreadUnsafeExample();<br>    <span class="hljs-keyword">final</span> CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(threadSize);<br>    ExecutorService executorService = Executors.newCachedThreadPool();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadSize; i++) &#123;<br>        executorService.execute(() -&gt; &#123;<br>            example.add();<br>            countDownLatch.countDown();<br>        &#125;);<br>    &#125;<br>    countDownLatch.await();<br>    executorService.shutdown();<br>    System.out.println(example.get());<br>&#125;<br><span class="hljs-comment">// 997 // 结果总是小于1000</span><br></code></pre></td></tr></table></figure><h3 id="并发出现线程不安全的本质什么"><a href="#并发出现线程不安全的本质什么" class="headerlink" title="并发出现线程不安全的本质什么"></a>并发出现线程不安全的本质什么</h3><p><strong>可见性: CPU缓存引起</strong><br>现在是多核CPU，每个CPU都有自己的多级缓存，这样就存在消息的同步问题</p><p><strong>原子性: 分时复用CPU引起</strong><br>不一定会一次性执行完可能出现中间状态，如线程切换<br>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行</p><p><strong>¶有序性: 重排序引起</strong><br>java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：<br><img src="https://user-images.githubusercontent.com/58756074/139373774-ff49a7a0-21c4-4b56-bb55-47c29ed3248b.png" alt="重排序"></p><h3 id="Java是怎么解决并发问题的-3个关键字，JMM和8个Happens-Before"><a href="#Java是怎么解决并发问题的-3个关键字，JMM和8个Happens-Before" class="headerlink" title="Java是怎么解决并发问题的? 3个关键字，JMM和8个Happens-Before"></a>Java是怎么解决并发问题的? 3个关键字，JMM和8个Happens-Before</h3><p><strong>可见性</strong><br>Java提供了volatile关键字来保证可见性，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。涉及MESI和bus snooping</p><p><strong>原子性</strong><br>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行<br>Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性</p><p><strong>¶有序性</strong><br>在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然JMM是通过Happens-Before 规则来保证有序性的</p><p>Happens-Before：<br>|规则|内容|<br>|:—-|:—-:|<br>|单一线程原则|在一个线程内，在程序前面的操作先行发生于后面的操作|<br>|管程锁定规则|一个 unlock 操作先行发生于后面对同一个锁的 lock 操作|<br>|volatile 变量规则|对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作|<br>|线程启动规则|Thread 对象的 start() 方法调用先行发生于此线程的每一个动作|<br>|线程加入规则|Thread 对象的结束先行发生于 join() 方法返回|<br>|线程中断规则|对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生|<br>|对象终结规则|一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始|<br>|传递性|A先于B，B先于C，A先于C|</p><h3 id="线程安全是不是非真即假-不是"><a href="#线程安全是不是非真即假-不是" class="headerlink" title="线程安全是不是非真即假? 不是"></a>线程安全是不是非真即假? 不是</h3><ol><li><p>不可变，不可变(Immutable)的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态（String，final修饰的基本数据类型，Enum，Number部分子类Long，Double）</p></li><li><p>绝对线程安全，不管运行时环境如何，调用者都不需要任何额外的同步措施。</p></li><li><p>相对线程安全，需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性，在 Java 语言中，大部分的线程安全类都属于这种类型</p></li><li><p>线程兼容，线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的</p></li><li><p>线程对立，线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免</p></li></ol><h3 id="线程安全有哪些实现思路"><a href="#线程安全有哪些实现思路" class="headerlink" title="线程安全有哪些实现思路?"></a>线程安全有哪些实现思路?</h3><ol><li>同步互斥（synchronized 和 ReentrantLock）</li><li>非阻塞同步 CAS</li><li>无同步方案，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性</li></ol><h3 id="如何理解并发和并行的区别"><a href="#如何理解并发和并行的区别" class="headerlink" title="如何理解并发和并行的区别"></a>如何理解并发和并行的区别</h3><p><strong>Ans</strong>:并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生<br>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件<br>并发是在资源有限的情况下尽可能多的处理事件</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reentrantlock</title>
    <link href="/2021/10/29/Reentrantlock/"/>
    <url>/2021/10/29/Reentrantlock/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p><img src="https://user-images.githubusercontent.com/58756074/139644363-38c26988-c2da-4606-8a07-33ec6333ccab.png" alt="ReentrantLock总揽"></p><h3 id="什么是可重入，什么是可重入锁-它用来解决什么问题"><a href="#什么是可重入，什么是可重入锁-它用来解决什么问题" class="headerlink" title="什么是可重入，什么是可重入锁? 它用来解决什么问题"></a>什么是可重入，什么是可重入锁? 它用来解决什么问题</h3><p><strong>Ans：</strong>可以多次重复进入，可重入锁及同一线程在取得锁资源的期间可以重复获取同一把锁</p><h3 id="ReentrantLock的核心是AQS，那么它怎么来实现的，继承吗-说说其类内部结构关系"><a href="#ReentrantLock的核心是AQS，那么它怎么来实现的，继承吗-说说其类内部结构关系" class="headerlink" title="ReentrantLock的核心是AQS，那么它怎么来实现的，继承吗? 说说其类内部结构关系"></a>ReentrantLock的核心是AQS，那么它怎么来实现的，继承吗? 说说其类内部结构关系</h3><p><img src="https://user-images.githubusercontent.com/58756074/139364193-9b86a4e7-58f6-424f-9c02-f2ff07348d42.png" alt="reentrantlock"></p><p>NonfairSync和FairSync继承Sync类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-comment">// 序列号</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">5179523762034025860L</span>;<br>    <br>    <span class="hljs-comment">// 获取锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-comment">// 非公平方式获取</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-comment">// 当前线程</span><br>        <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>        <span class="hljs-comment">// 获取状态</span><br>        <span class="hljs-keyword">int</span> c = getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 表示没有线程正在竞争该锁</span><br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123; <span class="hljs-comment">// 比较并设置状态成功，状态0表示锁没有被占用</span><br>                <span class="hljs-comment">// 设置当前线程独占</span><br>                setExclusiveOwnerThread(current); <br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 成功</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="hljs-comment">// 当前线程拥有该锁</span><br>            <span class="hljs-keyword">int</span> nextc = c + acquires; <span class="hljs-comment">// 增加重入次数</span><br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            <span class="hljs-comment">// 设置状态</span><br>            setState(nextc); <br>            <span class="hljs-comment">// 成功</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <br>        &#125;<br>        <span class="hljs-comment">// 失败</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 试图在共享模式下获取对象状态，此方法应该查询是否允许它在共享模式下获取对象状态，如果允许，则获取它</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> c = getState() - releases;<br>        <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) <span class="hljs-comment">// 当前线程不为独占线程</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException(); <span class="hljs-comment">// 抛出异常</span><br>        <span class="hljs-comment">// 释放标识</span><br>        <span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>; <br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            free = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-comment">// 已经释放，清空独占</span><br>            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>); <br>        &#125;<br>        <span class="hljs-comment">// 设置标识</span><br>        setState(c); <br>        <span class="hljs-keyword">return</span> free; <br>    &#125;<br>    <br>    <span class="hljs-comment">// 判断资源是否被当前线程占有</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// While we must in general read state before owner,</span><br>        <span class="hljs-comment">// we don&#x27;t need to do so to check if current thread is owner</span><br>        <span class="hljs-keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();<br>    &#125;<br><br>    <span class="hljs-comment">// 新生一个条件</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> ConditionObject <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConditionObject();<br>    &#125;<br><br>    <span class="hljs-comment">// Methods relayed from outer class</span><br>    <span class="hljs-comment">// 返回资源的占用线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> Thread <span class="hljs-title">getOwner</span><span class="hljs-params">()</span> </span>&#123;        <br>        <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">0</span> ? <span class="hljs-keyword">null</span> : getExclusiveOwnerThread();<br>    &#125;<br>    <span class="hljs-comment">// 返回状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHoldCount</span><span class="hljs-params">()</span> </span>&#123;            <br>        <span class="hljs-keyword">return</span> isHeldExclusively() ? getState() : <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 资源是否被占用</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLocked</span><span class="hljs-params">()</span> </span>&#123;        <br>        <span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * Reconstitutes the instance from a stream (that is, deserializes it).</span><br><span class="hljs-comment">        */</span><br>    <span class="hljs-comment">// 自定义反序列化逻辑</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;<br>        s.defaultReadObject();<br>        setState(<span class="hljs-number">0</span>); <span class="hljs-comment">// reset to unlocked state</span><br>    &#125;<br>&#125;　　<br></code></pre></td></tr></table></figure><p><strong>sync主要api：</strong></p><ul><li>abstract void lock()（被fair和nonfair实现）</li><li>nonfairTryAcquire （nonfair tryacquire直接调用）</li><li>tryRelease：尝试释放（state-releases）state到0则说明完全释放并设置独享线程为null（AOS）</li><li>isHeldExclusively：是否独占</li><li>newCondition：new ConditionObject()（方法来自AQS）</li><li>getOwner：得到占用资源的线程</li><li>getHoldCount：得到state数</li><li>isLocked：资源是否被占用</li></ul><h3 id="ReentrantLock是如何实现公平锁的"><a href="#ReentrantLock是如何实现公平锁的" class="headerlink" title="ReentrantLock是如何实现公平锁的"></a>ReentrantLock是如何实现公平锁的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 公平锁</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-comment">// 版本序列化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">3000897897090466540L</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 以独占模式获取对象，忽略中断</span><br>        acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * Fair version of tryAcquire.  Don&#x27;t grant access unless</span><br><span class="hljs-comment">        * recursive call or no waiters or is first.</span><br><span class="hljs-comment">        */</span><br>    <span class="hljs-comment">// 尝试公平获取锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-comment">// 获取当前线程</span><br>        <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>        <span class="hljs-comment">// 获取状态</span><br>        <span class="hljs-keyword">int</span> c = getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 状态为0</span><br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123; <span class="hljs-comment">// 不存在已经等待更久的线程并且比较并且设置状态成功</span><br>                <span class="hljs-comment">// 设置当前线程独占</span><br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="hljs-comment">// 状态不为0，即资源已经被线程占据</span><br>            <span class="hljs-comment">// 下一个状态</span><br>            <span class="hljs-keyword">int</span> nextc = c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 超过了int的表示范围</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            <span class="hljs-comment">// 设置状态</span><br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>FairSync跟踪lock方法的源码可知，当资源空闲时，它总是会先判断sync队列(AbstractQueuedSynchronizer中的数据结构)是否有等待时间更长的线程，如果存在，则将该线程加入到等待队列的尾部，实现了公平获取原则</p><h3 id="ReentrantLock是如何实现非公平锁的"><a href="#ReentrantLock是如何实现非公平锁的" class="headerlink" title="ReentrantLock是如何实现非公平锁的"></a>ReentrantLock是如何实现非公平锁的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 非公平锁</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-comment">// 版本号</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">7316153563782823691L</span>;<br><br>    <span class="hljs-comment">// 获得锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) <span class="hljs-comment">// 比较并设置状态成功，状态0表示锁没有被占用</span><br>            <span class="hljs-comment">// 把当前线程设置独占了锁</span><br>            setExclusiveOwnerThread(Thread.currentThread());<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 锁已经被占用，或者set失败</span><br>            <span class="hljs-comment">// 以独占模式获取对象，忽略中断</span><br>            acquire(<span class="hljs-number">1</span>); <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>        <span class="hljs-comment">//核心：判断是否资源可用，可用则独占setExclusiveOwnerThread(current)并标记state，如果不可用则判断是否拥有该lock，有则重入state+1，无则false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>NonfairSync从lock方法的源码可知，每一次都尝试获取锁，而并不会按照公平等待的原则进行等待，让等待时间最久的线程获得锁</p><h3 id="ReentrantLock默认实现的是公平还是非公平锁"><a href="#ReentrantLock默认实现的是公平还是非公平锁" class="headerlink" title="ReentrantLock默认实现的是公平还是非公平锁"></a>ReentrantLock默认实现的是公平还是非公平锁</h3><p>默认是采用的非公平策略获取锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 默认非公平策略</span><br>    sync = <span class="hljs-keyword">new</span> NonfairSync();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> FairSync() : <span class="hljs-keyword">new</span> NonfairSync(); <span class="hljs-comment">//true fair ,false nonfair</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用ReentrantLock实现公平和非公平锁的示例"><a href="#使用ReentrantLock实现公平和非公平锁的示例" class="headerlink" title="使用ReentrantLock实现公平和非公平锁的示例"></a>使用ReentrantLock实现公平和非公平锁的示例</h3><h3 id="ReentrantLock和Synchronized的对比"><a href="#ReentrantLock和Synchronized的对比" class="headerlink" title="ReentrantLock和Synchronized的对比"></a>ReentrantLock和Synchronized的对比</h3><p>Synchronized只有锁只与一个条件(是否获取锁)相关联，不灵活，后来Condition与Lock的结合解决了这个问题（实现管程模型）</p><p>多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。高并发的情况下会导致性能下降。ReentrantLock的lockInterruptibly()方法可以优先考虑响应中断。 一个线程等待时间过长，它可以中断自己，然后ReentrantLock响应这个中断，不再让这个线程继续等待。有了这个机制，使用ReentrantLock时就不会像synchronized那样产生死锁了</p><p>可重入锁，同一把锁可以在持有时再进行获取(synchronized也可以)，获取几次也必须要释放几次，不然会造成死锁 </p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AQS</title>
    <link href="/2021/10/28/AQS/"/>
    <url>/2021/10/28/AQS/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p><img src="https://user-images.githubusercontent.com/58756074/139618563-b4cc63a9-3e6b-4d7f-adff-d47c1d3deb02.png" alt="AQS总揽"></p><h3 id="什么是AQS-为什么它是核心"><a href="#什么是AQS-为什么它是核心" class="headerlink" title="什么是AQS? 为什么它是核心"></a>什么是AQS? 为什么它是核心</h3><p><strong>Ans</strong>:AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。</p><h3 id="AQS的核心思想是什么-它是怎么实现的-底层数据结构"><a href="#AQS的核心思想是什么-它是怎么实现的-底层数据结构" class="headerlink" title="AQS的核心思想是什么? 它是怎么实现的? 底层数据结构"></a>AQS的核心思想是什么? 它是怎么实现的? 底层数据结构</h3><p><strong>Ans</strong>:AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH（虚拟的双向队列）队列锁实现的，即将暂时获取不到锁的线程加入到队列中</p><p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。<br>AbstractQueuedSynchronizer类有两个内部类，分别为Node类与ConditionObject类</p><p>Node：每个线程被阻塞的线程都会被封装成一个Node结点，放入队列。每个节点包含了一个Thread类型的引用，并且每个节点都存在一个状态<br>状态：</p><ul><li>CANCELLED（1）表示当前的线程被取消</li><li>SIGNAL （-1）当前节点的后继节点包含的线程需要运行，需要进行unpark操作</li><li>CONDITION（-2）表示当前节点在等待condition，也就是在condition queue中</li><li>PROPAGATE （-3） 当前场景下后续的acquireShared能够得以执行</li><li>0 表示当前节点在sync queue中，等待着获取锁</li></ul><p>Condition：await、signal方法，用来等待条件、释放条件<br><img src="https://user-images.githubusercontent.com/58756074/139201031-f1fe0071-1f35-439d-ab3c-7db2fc142c58.png" alt="aqs底层"><br>其中Sync queue，即同步队列，是双向链表，包括head结点和tail结点，head结点主要用作后续的调度。而Condition queue（线程不满足某条件入队）不是必须的，其是一个单向链表，只有当使用Condition时，才会存在此单向链表。并且可能会有多个Condition queue。条件队列中的线程实际上已经获取资源但没能继续执行下去的条件所以加入条件队列释放资源让渡给其他线程执行，若未来满足条件则会转移到同步队列继续参与竞争，这两个队列类似OS中PCB的就绪队列和阻塞队列。</p><p>简单描述一下sync队列的入队出队：新节点加入tail后面，tail进行CAS，将tail指针移动到新节点，出队释放唤醒head的后继节点，抢锁成功，heda指针往后一位原先的head.next成为head</p><p>AQS继承AbstractOwnableSynchronizer可以设置独占资源线程和获取独占资源线程。分别为setExclusiveOwnerThread与getExclusiveOwnerThread方法，这两个方法会被子类调用<br>AbstractQueuedSynchronizer：头结点head，尾结点tail，状态state、自旋时间spinForTimeoutThreshold，还有AbstractQueuedSynchronizer抽象的属性在内存中的偏移地址，通过该偏移地址，可以获取和设置该属性的值，同时还包括一个静态初始化块，用于加载内存偏移地址</p><h3 id="AQS有哪些核心的方法"><a href="#AQS有哪些核心的方法" class="headerlink" title="AQS有哪些核心的方法"></a>AQS有哪些核心的方法</h3><p><strong>Ans</strong>:aquire（该方法以独占模式获取(资源)，忽略中断，即线程在aquire过程中，中断此线程是无效的）<br><img src="https://user-images.githubusercontent.com/58756074/139203709-a4ac3160-9dfd-415f-b381-6ee961d00280.png" alt="aquire流程"><br>调用子类实现tryAcquire独占对象，成功则获取不成功addWaiter加入等待队列（Sync queue）如果sync queue队列还没有初始化，则会使用enq插入队列中，调用acquireQueued方法，此方法完成的功能是Sync queue中的结点不断尝试获取资源，若成功，则返回true，否则，返回false</p><p><strong>tryAcquire</strong> 子类实现<br><strong>addWaiter：</strong>将新node放在tail上（node.prev = oldtail,tail = node, oldtail.next = node)<br>如果queue不存在则<strong>enq</strong>空节点为head，插入node<br><strong>acquireQueue</strong> 前节点为head且tryacquire成功，设置头结点为当前节点返回<br>否则<strong>shouldParkAfterFailedAcquire</strong>只有当该节点的前驱结点的状态为SIGNAL时，才可以对该结点所封装的线程进行park操作。否则，将不能进行park操作<br>和<strong>parkAndCheckInterrupt</strong>：先执行park操作，即禁用当前线程，然后返回该线程是否已经被中断<br>finally如果退出时获锁失败<strong>cancelAcquire</strong>该方法完成的功能就是取消当前线程对资源的获取，即设置该结点的状态为CANCELLED<br>并<strong>unparkSuccessor</strong>unpack后节点</p><ul><li>每一个结点都是由前一个结点唤醒</li><li>当结点发现前驱结点是head并且尝试获取成功，则会轮到该线程运行</li><li>condition queue中的结点向sync queue中转移是通过signal操作完成的</li><li>当结点的状态为SIGNAL时，表示后面的结点需要运行</li></ul><p>release释放资源（tryRelease的默认实现是抛出异常，需要具体的子类实现，如果tryRelease成功，那么如果头结点不为空并且头结点的状态不为0，则释放头结点的后继结点）<br><strong>release</strong>：tryRelease并unparkSuccessor(head)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;<span class="hljs-comment">//共享变量，使用volatile修饰保证线程可见性</span><br><br><span class="hljs-comment">//返回同步状态的当前值</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> state;<br>&#125;<br> <span class="hljs-comment">// 设置同步状态的值</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newState)</span> </span>&#123; <br>        state = newState;<br>&#125;<br><span class="hljs-comment">//原子地(CAS操作)将同步状态值设置为给定值update如果当前同步状态的值等于expect(期望值)</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expect, <span class="hljs-keyword">int</span> update)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-keyword">this</span>, stateOffset, expect, update);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="AQS定义什么样的资源获取方式"><a href="#AQS定义什么样的资源获取方式" class="headerlink" title="AQS定义什么样的资源获取方式"></a>AQS定义什么样的资源获取方式</h3><p><strong>Ans</strong>:独占（只有一个线程能访问执行，又根据是否按队列的顺序分为公平锁和非公平锁）和共享（多个线程可同时访问执行）<br>AQS定义了两种资源获取方式：<br>独占(只有一个线程能访问执行，又根据是否按队列的顺序分为公平锁和非公平锁，如ReentrantLock) </p><p>共享(多个线程可同时访问执行，如Semaphore、CountDownLatch、 CyclicBarrier )。</p><p>ReentrantReadWriteLock可以看成是组合式，允许多个线程同时对某一资源进行读</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护(如获取资源失败入队/唤醒出队等)，AQS已经在上层已经帮我们实现好了</p><h3 id="AQS底层使用了什么样的设计模式-模板"><a href="#AQS底层使用了什么样的设计模式-模板" class="headerlink" title="AQS底层使用了什么样的设计模式? 模板"></a>AQS底层使用了什么样的设计模式? 模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">isHeldExclusively()<span class="hljs-comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span><br>tryAcquire(<span class="hljs-keyword">int</span>)<span class="hljs-comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span><br>tryRelease(<span class="hljs-keyword">int</span>)<span class="hljs-comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span><br>tryAcquireShared(<span class="hljs-keyword">int</span>)<span class="hljs-comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><br>tryReleaseShared(<span class="hljs-keyword">int</span>)<span class="hljs-comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span><br></code></pre></td></tr></table></figure><p>默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用</p><h3 id="AQS的应用示例"><a href="#AQS的应用示例" class="headerlink" title="AQS的应用示例"></a>AQS的应用示例</h3>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAS</title>
    <link href="/2021/10/28/CAS/"/>
    <url>/2021/10/28/CAS/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="线程安全的实现方法有哪些"><a href="#线程安全的实现方法有哪些" class="headerlink" title="线程安全的实现方法有哪些"></a>线程安全的实现方法有哪些</h3><p><strong>Ans</strong>:</p><ul><li>互斥同步: synchronized 和 ReentrantLock</li><li>非阻塞同步: CAS, AtomicXXXX</li><li>无同步方案: 栈封闭，Thread Local，可重入代码</li></ul><h3 id="什么是CAS（Compare-And-Swap）"><a href="#什么是CAS（Compare-And-Swap）" class="headerlink" title="什么是CAS（Compare-And-Swap）"></a>什么是CAS（Compare-And-Swap）</h3><p><strong>Ans</strong>:CAS是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值，经过调查发现，其实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口</p><p>CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较下在旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换<br>CAS操作是原子性的，所以多线程并发使用CAS更新数据时，可以不使用锁。JDK中大量使用了CAS来更新数据而防止加锁(synchronized 重量级锁)来保持原子更新</p><h3 id="CAS使用示例，结合AtomicInteger给出示例"><a href="#CAS使用示例，结合AtomicInteger给出示例" class="headerlink" title="CAS使用示例，结合AtomicInteger给出示例"></a>CAS使用示例，结合AtomicInteger给出示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestwithSynchronized</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> i++;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestwithCAS</span> </span>&#123;<br>    <span class="hljs-keyword">private</span>  AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> i.addAndGet(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CAS会有哪些问题"><a href="#CAS会有哪些问题" class="headerlink" title="CAS会有哪些问题"></a>CAS会有哪些问题</h3><p>CAS 方式为乐观锁，synchronized 为悲观锁。因此使用 CAS 解决并发问题通常情况下性能更优<br>问题：<br><strong>ABA</strong>：<br>因为CAS需要在操作值的时候，检查值有没有发生变化，比如没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时则会发现它的值没有发生变化，但是实际上却变化了</p><p><strong>循环时间长开销大</strong>：<br>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p><p><strong>只能保证一个共享变量的原子操作</strong>：<br>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁</p><h3 id="针对这这些问题，Java提供了哪几个解决的"><a href="#针对这这些问题，Java提供了哪几个解决的" class="headerlink" title="针对这这些问题，Java提供了哪几个解决的"></a>针对这这些问题，Java提供了哪几个解决的</h3><p>ABA：ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A-&gt;B-&gt;A就会变成1A-&gt;2B-&gt;3A<br>JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题：这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值</p><p>循环时间长开销大：如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：第一，它可以延迟流水线执行命令(de-pipeline)，使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；第二，它可以避免在退出循环的时候因内存顺序冲突(Memory Order Violation)而引起CPU流水线被清空(CPU Pipeline Flush)，从而提高CPU的执行效率</p><p>只能保证一个共享变量的原子操作：从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作</p><h3 id="AtomicInteger底层实现-CAS-volatile"><a href="#AtomicInteger底层实现-CAS-volatile" class="headerlink" title="AtomicInteger底层实现? CAS+volatile"></a>AtomicInteger底层实现? CAS+volatile</h3><p>volatile保证线程的可见性，多线程并发时，一个线程修改数据，可以保证其它线程立马看到修改后的值</p><p>CAS 保证数据更新的原子性</p><h3 id="请阐述你对Unsafe类的理解"><a href="#请阐述你对Unsafe类的理解" class="headerlink" title="请阐述你对Unsafe类的理解?"></a>请阐述你对Unsafe类的理解?</h3><p><strong>Ans</strong>:主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险<br><img src="https://user-images.githubusercontent.com/58756074/139192305-e04f087f-ea3b-4e77-bce3-60b394ea6f24.png" alt="unsafe"><br>如上图所示，Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类</p><p>我们发现Unsafe只提供了3种CAS方法：compareAndSwapObject、compareAndSwapInt和compareAndSwapLong。都是native方法</p><h3 id="说说你对Java原子类的理解-包含13个，4组分类，说说作用和使用场景"><a href="#说说你对Java原子类的理解-包含13个，4组分类，说说作用和使用场景" class="headerlink" title="说说你对Java原子类的理解? 包含13个，4组分类，说说作用和使用场景"></a>说说你对Java原子类的理解? 包含13个，4组分类，说说作用和使用场景</h3><p>原子更新基本类型：</p><ul><li>AtomicBoolean: 原子更新布尔类型。</li><li>AtomicInteger: 原子更新整型。</li><li>AtomicLong: 原子更新长整型。</li></ul><p>原子更新数组：</p><ul><li>AtomicIntegerArray: 原子更新整型数组里的元素。</li><li>AtomicLongArray: 原子更新长整型数组里的元素。</li><li>AtomicReferenceArray: 原子更新引用类型数组里的元素。<br>常用方法：get（int index）获取索引为index的元素值，compareAndSet(int i,E expect,E update): 如果当前值等于预期值，则以原子方式将数组位置i的元素设置为update值</li></ul><p>原子更新引用类型：</p><ul><li>AtomicReference: 原子更新引用类型。</li><li>AtomicStampedReference: 原子更新引用类型, 内部使用Pair来存储元素值及其版本号。</li><li>AtomicMarkableReferce: 原子更新带有标记位的引用类型。<br>这三个类提供的方法都差不多，首先构造一个引用对象，然后把引用对象set进Atomic类，然后调用compareAndSet等一些方法去进行原子操作，原理都是基于Unsafe实现，但AtomicReferenceFieldUpdater略有不同，更新的字段必须用volatile修饰</li></ul><p>原子更新字段类：</p><ul><li>AtomicIntegerFieldUpdater: 原子更新整型的字段的更新器</li><li>AtomicLongFieldUpdater: 原子更新长整型字段的更新器</li><li>AtomicStampedFieldUpdater: 原子更新带有版本号的引用类型</li><li>AtomicReferenceFieldUpdater：字段必须是volatile类型的，在线程之间共享变量时保证立即可见，不能加static，不能final<br>对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int/long类型的字段，不能修改其包装类型(Integer/Long)。如果要修改包装类型就需要使用AtomicReferenceFieldUpdater</li></ul><h3 id="AtomicStampedReference是什么"><a href="#AtomicStampedReference是什么" class="headerlink" title="AtomicStampedReference是什么"></a>AtomicStampedReference是什么</h3><p><strong>Ans</strong>:原子更新引用类型, 内部使用Pair来存储元素值及其版本号</p><h3 id="AtomicStampedReference是怎么解决ABA的-内部使用Pair来存储元素值及其版本号"><a href="#AtomicStampedReference是怎么解决ABA的-内部使用Pair来存储元素值及其版本号" class="headerlink" title="AtomicStampedReference是怎么解决ABA的? 内部使用Pair来存储元素值及其版本号"></a>AtomicStampedReference是怎么解决ABA的? 内部使用Pair来存储元素值及其版本号</h3><p><strong>Ans</strong>:AtomicStampedReference主要维护包含一个对象引用以及一个可以自动更新的整数”stamp”的pair对象来解决ABA问题</p><ul><li>如果元素值和版本号都没有变化，并且和新的也相同，返回true</li><li>如果元素值和版本号都没有变化，并且和新的不完全相同，就构造一个新的Pair对象并执行CAS更新pair<br>解决思路：</li><li>首先，使用版本号控制</li><li>其次，不重复使用节点(Pair)的引用，每次都新建一个新的Pair来作为CAS比较的对象，而不是复用旧的</li><li>最后，外部传入元素值及版本号，而不是节点(Pair)的引用<h3 id="java中还有哪些类可以解决ABA的问题-AtomicMarkableReference"><a href="#java中还有哪些类可以解决ABA的问题-AtomicMarkableReference" class="headerlink" title="java中还有哪些类可以解决ABA的问题? AtomicMarkableReference"></a>java中还有哪些类可以解决ABA的问题? AtomicMarkableReference</h3></li></ul><p><strong>Ans</strong>:AtomicMarkableReference，它不是维护一个版本号，而是维护一个boolean类型的标记，标记值有修改，了解一下。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>final</title>
    <link href="/2021/10/28/final/"/>
    <url>/2021/10/28/final/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="所有的final修饰的字段都是编译期常量吗"><a href="#所有的final修饰的字段都是编译期常量吗" class="headerlink" title="所有的final修饰的字段都是编译期常量吗"></a>所有的final修饰的字段都是编译期常量吗</h3><p><strong>Ans</strong>:不是所有的final修饰的字段都是编译期常量，只是k的值在被初始化后无法被更改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-comment">//编译期常量</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> J = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-comment">//非编译期常量</span><br>    Random r = <span class="hljs-keyword">new</span> Random();<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> k = r.nextInt();<span class="hljs-comment">//k的值由随机数对象决定</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>题外话：final一般只需在调用前赋值就行（一般在constructor中赋值），不过如果static final则需一开始赋值</p><h3 id="如何理解private所修饰的方法是隐式的final"><a href="#如何理解private所修饰的方法是隐式的final" class="headerlink" title="如何理解private所修饰的方法是隐式的final"></a>如何理解private所修饰的方法是隐式的final</h3><p><strong>Ans</strong>:private方法无法被继承，无覆盖这一说<br>类中所有private方法都隐式地指定为final的，由于无法取用private方法，所以也就不能覆盖它。可以对private方法增添final关键字，但这样做并没有什么好处</p><h3 id="说说final类型的类如何拓展-比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString-的方法，应该如何做"><a href="#说说final类型的类如何拓展-比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString-的方法，应该如何做" class="headerlink" title="说说final类型的类如何拓展? 比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做"></a>说说final类型的类如何拓展? 比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做</h3><p><strong>Ans</strong>:写个新类复用final类方法，再新增方法</p><h3 id="final方法可以被重载吗-可以"><a href="#final方法可以被重载吗-可以" class="headerlink" title="final方法可以被重载吗? 可以"></a>final方法可以被重载吗? 可以</h3><p><strong>Ans</strong>:final方法可重载，支持多态</p><h3 id="父类的final方法能不能够被子类重写-不可以"><a href="#父类的final方法能不能够被子类重写-不可以" class="headerlink" title="父类的final方法能不能够被子类重写? 不可以"></a>父类的final方法能不能够被子类重写? 不可以</h3><p><strong>Ans</strong>:final方法是无法被覆盖的</p><h3 id="说说final域重排序规则"><a href="#说说final域重排序规则" class="headerlink" title="说说final域重排序规则"></a>说说final域重排序规则</h3><p><strong>基本类型</strong>：<br>写final域的重排序规则禁止对final域的写重排序到构造函数之外，这个规则的实现主要包含了两个方面：</p><ul><li>JMM禁止编译器把final域的写重排序到构造函数之外</li><li>编译器会在final域写之后，构造函数return之前，插入一个storestore屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外<br>写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域就不具有这个保障。</li></ul><p>读final域重排序规则为：在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。(注意，这个规则仅仅是针对处理器)，处理器会在读final域操作的前面插入一个LoadLoad屏障。实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。</p><p>读对象的普通域被重排序到了读对象引用的前面就会出现线程B还未读到对象引用就在读取该对象的普通域变量，这显然是错误的操作。而final域的读操作就“限定”了在读final域变量前已经读到了该对象的引用，从而就可以避免这种情况。<br>人话来说不做final限定可能导致线程在读对象引用前就读普通field但final可以保证这种重排序不被发生</p><p><strong>引用类型</strong>：<br>写规则：除不得重排到构造函数之外，禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序<br>对final修饰对象的成员写入不能和该对象的引用赋值重排序</p><h3 id="说说final的原理"><a href="#说说final的原理" class="headerlink" title="说说final的原理"></a>说说final的原理</h3><p>写final域会要求编译器在final域写之后，构造函数返回前插入一个StoreStore屏障。读final域的重排序规则会要求编译器在读final域的操作前插入一个LoadLoad屏障</p><h3 id="使用-final-的限制条件和局限性"><a href="#使用-final-的限制条件和局限性" class="headerlink" title="使用 final 的限制条件和局限性"></a>使用 final 的限制条件和局限性</h3><p><strong>Ans</strong>:当声明一个 final 成员时，必须在构造函数退出前设置它的值。将指向对象的成员声明为 final 只能将该引用设为不可变的，而非所指的对象。(list)<br>如果一个对象将会在多个线程中访问并且你并没有将其成员声明为 final，则必须提供其他方式保证线程安全<br>“ 其他方式 “ 可以包括声明成员为 volatile，使用 synchronized 或者显式 Lock 控制所有该成员的访问</p><h3 id="类型自动转换问题"><a href="#类型自动转换问题" class="headerlink" title="类型自动转换问题"></a>类型自动转换问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">byte</span> b1=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">byte</span> b2=<span class="hljs-number">3</span>;<br><span class="hljs-keyword">byte</span> b3=b1+b2;<span class="hljs-comment">//当程序执行到这一行的时候会出错，因为b1、b2可以自动转换成int类型的变量，运算时java虚拟机对它进行了转换，结果导致把一个int赋值给byte-----出错</span><br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> b1=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> b2=<span class="hljs-number">3</span>;<br><span class="hljs-keyword">byte</span> b3=b1+b2;<span class="hljs-comment">//不会出错，相信你看了上面的解释就知道原因了。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>volatile</title>
    <link href="/2021/10/28/volatile/"/>
    <url>/2021/10/28/volatile/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="volatile关键字的作用是什么"><a href="#volatile关键字的作用是什么" class="headerlink" title="volatile关键字的作用是什么"></a>volatile关键字的作用是什么</h3><ul><li>防重排序<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singleton;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数私有，禁止外部实例化</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) &#123;<br>                    singleton = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>实例化对象过程：分配内存空间，初始化对象，将内存空间地址赋值给对应引用<br>由于操作系统对对指令进行重排序可能会变成：分配内存空间，将内存空间地址赋值给对应引用，初始化对象<br>多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量</li></ul><p>为了实现 volatile 内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序<br>内存屏障|说明<br>—|:–:<br>StoreStore|禁止上面的普通写和下面的 volatile 写重排序<br>StoreLoad|防止上面的 volatile 写与下面可能有的 volatile 读/写重排序<br>LoadLoad |禁止下面所有的普通读操作和上面的 volatile 读重排序<br>LoadStore|禁止下面所有的普通写操作和上面的 volatile 读重排序</p><ul><li>插入屏障：<ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障</li></ul></li></ul><ul><li><p>实现可见性<br>可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。</p></li><li><p>保证原子性:单次读/写</p></li></ul><p>volatile不能保证完全的原子性，只能保证单次的读/写操作具有原子性</p><h3 id="volatile能保证原子性吗"><a href="#volatile能保证原子性吗" class="headerlink" title="volatile能保证原子性吗"></a>volatile能保证原子性吗</h3><p><strong>Ans</strong>:volatile不能保证完全的原子性，只能保证单次的读/写操作具有原子性</p><h3 id="之前32位机器上共享的long和double变量的为什么要用volatile-现在64位机器上是否也要设置呢"><a href="#之前32位机器上共享的long和double变量的为什么要用volatile-现在64位机器上是否也要设置呢" class="headerlink" title="之前32位机器上共享的long和double变量的为什么要用volatile? 现在64位机器上是否也要设置呢?"></a>之前32位机器上共享的long和double变量的为什么要用volatile? 现在64位机器上是否也要设置呢?</h3><p><strong>Ans</strong>:因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读/写可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读/写操作都具有原子性。</p><p>目前各种平台下的商用虚拟机都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不把long 和 double 变量专门声明为 volatile多数情况下也是不会错的</p><h3 id="i-为什么不能保证原子性"><a href="#i-为什么不能保证原子性" class="headerlink" title="i++为什么不能保证原子性"></a>i++为什么不能保证原子性</h3><p><strong>Ans</strong>:对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作<br>i++ = 读取i，对i+1，将i写回内存<br>volatile是无法保证这三个操作是具有原子性的，我们可以通过AtomicInteger或者Synchronized来保证+1操作的原子性</p><h3 id="volatile是如何实现可见性的-内存屏障"><a href="#volatile是如何实现可见性的-内存屏障" class="headerlink" title="volatile是如何实现可见性的? 内存屏障"></a>volatile是如何实现可见性的? 内存屏障</h3><p><strong>Ans</strong>:volatile保证数据发生改变立即写入内存，在总线嗅探的帮助下其他处理器可以马上知道自己的缓存数据已脏，下次调用的时候直接从内存读取新数据<br>Memory Barrier是一个 CPU 指令，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        a = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test test = <span class="hljs-keyword">new</span> Test();<br>        test.update();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">0x0000000002951563: and    $0xffffffffffffff87,%rdi<br>0x0000000002951567: je     0x00000000029515f8<br>0x000000000295156d: test   $0x7,%rdi<br>0x0000000002951574: jne    0x00000000029515bd<br>0x0000000002951576: test   $0x300,%rdi<br>0x000000000295157d: jne    0x000000000295159c<br>0x000000000295157f: and    $0x37f,%rax<br>0x0000000002951586: mov    %rax,%rdi<br>0x0000000002951589: or     %r15,%rdi<br>0x000000000295158c: lock cmpxchg %rdi,(%rdx)  //在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令<br>0x0000000002951591: jne    0x0000000002951a15<br>0x0000000002951597: jmpq   0x00000000029515f8<br>0x000000000295159c: mov    0x8(%rdx),%edi<br>0x000000000295159f: shl    $0x3,%rdi<br>0x00000000029515a3: mov    0xa8(%rdi),%rdi<br>0x00000000029515aa: or     %r15,%rdi<br></code></pre></td></tr></table></figure><p>lock前缀：将当前处理器缓存行的数据写回到系统内存，写回内存的操作会使在其他 CPU 里缓存了该内存地址的额数据无效<br>如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</p><p>联动OS：为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p><h3 id="volatile是如何实现有序性的-happens-before等"><a href="#volatile是如何实现有序性的-happens-before等" class="headerlink" title="volatile是如何实现有序性的? happens-before等"></a>volatile是如何实现有序性的? happens-before等</h3><p><strong>Ans</strong>:happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读</p><h3 id="说下volatile的应用场景"><a href="#说下volatile的应用场景" class="headerlink" title="说下volatile的应用场景"></a>说下volatile的应用场景</h3><p><strong>Ans</strong>:状态标志（仅仅是使用一个布尔状态标志），开销较低的读－写锁策略（synchronized保证原子性，volatile保证可见性），double-checked（单例模式防止重排序）</p><p>条件：</p><ul><li>对变量的写操作不依赖于当前值</li><li>该变量没有包含在具有其他变量的不变式中</li><li>只有在状态真正独立于程序内其他内容时才能使用 volatile</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>synchronized</title>
    <link href="/2021/10/27/synchronized/"/>
    <url>/2021/10/27/synchronized/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Synchronized可以作用在哪里-分别通过对象锁和类锁进行举例"><a href="#Synchronized可以作用在哪里-分别通过对象锁和类锁进行举例" class="headerlink" title="Synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例"></a>Synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例</h3><p><strong>Ans</strong>：对象锁分为方法锁和同步块锁，其中方法锁默认作用于当前实例也就是this，同步块代码锁则是自定义锁。类锁则是指synchronized的方法锁作用在静态方法上或者是类上，这类锁无论多少线程访问都只有一把锁。</p><ul><li>对象锁 (默认this,指定对象)</li></ul><p>包括方法锁(默认锁对象为this,当前实例对象)和同步代码块锁(自己指定锁对象)</p><p><strong>代码块形式：手动指定锁定对象，也可是是this,也可以是自定义的锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instance = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 同步代码块形式——锁为this,两个线程使用的锁是一样的,线程1必须要等到线程0释放了该锁后，才能执行</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(instance);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(instance);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*output：</span><br><span class="hljs-comment">我是线程Thread-0</span><br><span class="hljs-comment">Thread-0结束</span><br><span class="hljs-comment">我是线程Thread-1</span><br><span class="hljs-comment">Thread-1结束</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instence = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br>    <span class="hljs-comment">// 创建2把锁</span><br>    Object block1 = <span class="hljs-keyword">new</span> Object();<br>    Object block2 = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 这个代码块使用的是第一把锁，当他释放后，后面的代码块由于使用的是第二把锁，因此可以马上执行</span><br>        <span class="hljs-keyword">synchronized</span> (block1) &#123;<br>            System.out.println(<span class="hljs-string">&quot;block1锁,我是线程&quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;block1锁,&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (block2) &#123;<br>            System.out.println(<span class="hljs-string">&quot;block2锁,我是线程&quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;block2锁,&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(instence);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(instence);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*output：</span><br><span class="hljs-comment">block1锁,我是线程Thread-0</span><br><span class="hljs-comment">block1锁,Thread-0结束</span><br><span class="hljs-comment">block2锁,我是线程Thread-0　　// 可以看到当第一个线程在执行完第一段同步代码块之后，第二个同步代码块可以马上得到执行，因为他们使用的锁不是同一把</span><br><span class="hljs-comment">block1锁,我是线程Thread-1</span><br><span class="hljs-comment">block2锁,Thread-0结束</span><br><span class="hljs-comment">block1锁,Thread-1结束</span><br><span class="hljs-comment">block2锁,我是线程Thread-1</span><br><span class="hljs-comment">block2锁,Thread-1结束</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>方法锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instence = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        method();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(instence);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(instence);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*output：</span><br><span class="hljs-comment">我是线程Thread-0</span><br><span class="hljs-comment">Thread-0结束</span><br><span class="hljs-comment">我是线程Thread-1</span><br><span class="hljs-comment">Thread-1结束</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li>类锁 （指synchronize修饰静态的方法或指定锁对象为Class对象）</li></ul><p>静态方法都属于类所以无论是修饰静态方法还是指定对象为class，哪个线程访问它，需要的锁都只有一把</p><h3 id="Synchronized本质上是通过什么保证线程安全的-分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理"><a href="#Synchronized本质上是通过什么保证线程安全的-分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理" class="headerlink" title="Synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理"></a>Synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理</h3><p><strong>Ans</strong>: 通过Monitor来控制线程对对象的访问，同一时间一个对象只能和一个monitor关联而一个monitor在同一时间只能被一个线程获得，monitor保证了互斥并且锁是可重入的当线程获取该对象锁后，计数器+1，释放-1，当计时器为0时下一个线程可以从同步队列中获取锁。通过sychronized的happens-before，对同一个监视器的解锁，happens-before于对该监视器的加锁即先进入修改线程的结果对后来的线程是可见的</p><ul><li>加锁和释放锁的原理</li></ul><p>Monitor：通过反编译可以看到有这么两个指令<strong>monitorenter，monitorexit</strong></p><p>monitorenter：</p><ul><li>monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待</li><li>如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加</li><li>这把锁已经被别的线程获取了，等待锁释放</li></ul><p>monitorexit：<br>释放对于monitor的所有权，释放过程很简单，就是讲monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁</p><p><img src="https://user-images.githubusercontent.com/58756074/138994203-9d01a992-aa14-4427-941f-f55a0ebc81e4.png" alt="java-thread-x-key-schronized-2"><br><strong>可重入原理：加锁次数计数器</strong><br>Synchronized先天具有重入性。每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一</p><p><strong>保证可见性的原理：内存模型和happens-before规则</strong><br>Synchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁</p><h3 id="Synchronized有什么样的缺陷-Java-Lock是怎么弥补这些缺陷的"><a href="#Synchronized有什么样的缺陷-Java-Lock是怎么弥补这些缺陷的" class="headerlink" title="Synchronized有什么样的缺陷? Java Lock是怎么弥补这些缺陷的"></a>Synchronized有什么样的缺陷? Java Lock是怎么弥补这些缺陷的</h3><p><strong>Ans</strong> 缺陷：不够灵活加锁释放时机单一（Condition与Lock的结合解决了这个问题），效率低锁释放情况少（一种是代码正常运行结束释放锁，另一种是产生异常释放锁），试图获得锁时不能设定超时，不能中断一个正在试图获得锁的线程（定时和中断lock都可以做到），无法知道是否成功获取到了锁（lock可以知道tryLock()）</p><h3 id="Synchronized和Lock的对比，和选择"><a href="#Synchronized和Lock的对比，和选择" class="headerlink" title="Synchronized和Lock的对比，和选择"></a>Synchronized和Lock的对比，和选择</h3><p><strong>Ans</strong>：在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错</p><h3 id="Synchronized在使用时有何注意事项"><a href="#Synchronized在使用时有何注意事项" class="headerlink" title="Synchronized在使用时有何注意事项?"></a>Synchronized在使用时有何注意事项?</h3><ul><li>锁对象不能为空，因为锁的信息都保存在对象头里</li><li>避免死锁</li><li>作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错</li><li>在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错</li></ul><h3 id="Synchronized修饰的方法在抛出异常时-会释放锁吗"><a href="#Synchronized修饰的方法在抛出异常时-会释放锁吗" class="headerlink" title="Synchronized修饰的方法在抛出异常时,会释放锁吗"></a>Synchronized修饰的方法在抛出异常时,会释放锁吗</h3><p><strong>Ans</strong>:synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁</p><h3 id="多个线程等待同一个synchronized锁的时候，JVM如何选择下一个获取锁的线程"><a href="#多个线程等待同一个synchronized锁的时候，JVM如何选择下一个获取锁的线程" class="headerlink" title="多个线程等待同一个synchronized锁的时候，JVM如何选择下一个获取锁的线程"></a>多个线程等待同一个synchronized锁的时候，JVM如何选择下一个获取锁的线程</h3><p><strong>Ans</strong>:多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。高并发的情况下会导致性能下降。<br>这个问题就涉及到内部锁的调度机制，线程获取 synchronized 对应的锁，也是有具体的调度算法的，这个和具体的虚拟机版本和实现都有关系，所以下一个获取锁的线程是事先没办法预测的<br>当持有锁的这个线程，释放了锁之后，会唤醒该锁对象同步队列中的所有线程，这些线程会继续尝试抢锁</p><h3 id="Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法"><a href="#Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法" class="headerlink" title="Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法"></a>Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法</h3><p><strong>Ans</strong>: 优化 synchronized 的使用范围，让临界区的代码在符合要求的情况下尽可能的小.使用其他类型的 lock（锁），synchronized 使用的锁经过 jdk 版本的升级，性能已经大幅提升了，但相对于更加轻量级的锁（如读写锁）还是偏重一点，所以可以选择更合适的锁</p><h3 id="我想更加灵活地控制锁的释放和获取-现在释放锁和获取锁的时机都被规定死了-，怎么办"><a href="#我想更加灵活地控制锁的释放和获取-现在释放锁和获取锁的时机都被规定死了-，怎么办" class="headerlink" title="我想更加灵活地控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办"></a>我想更加灵活地控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办</h3><p><strong>Ans</strong>:Synchronized只有锁只与一个条件(是否获取锁)相关联，不灵活，后来Condition与Lock的结合解决了这个问题。</p><h3 id="什么是锁的升级和降级-什么是JVM里的偏向锁、轻量级锁、重量级锁"><a href="#什么是锁的升级和降级-什么是JVM里的偏向锁、轻量级锁、重量级锁" class="headerlink" title="什么是锁的升级和降级? 什么是JVM里的偏向锁、轻量级锁、重量级锁"></a>什么是锁的升级和降级? 什么是JVM里的偏向锁、轻量级锁、重量级锁</h3><p><strong>Ans</strong>：对于不同的竞争情况，会自动切换到合适的锁实现。当没有竞争出现时，默认使用偏斜锁，也即是在对象头的 Mark Word 部分设置线程ID，来表示锁对象偏向的线程，但这并不是互斥锁；当有其他线程试图锁定某个已被偏斜过的锁对象，JVM 就撤销偏斜锁，切换到轻量级锁，轻量级锁依赖 CAS 操作对象头的 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则进一步升级为重量级锁。锁的降级发生在当 JVM 进入安全点后，检查是否有闲置的锁，并试图进行降级。锁的升级和降级都是出于性能的考虑。</p><p>jdk 1.6引入大量实现优化：</p><ul><li>**锁粗化(Lock Coarsening)**：（多次上锁变为一次大范围锁）也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁</li><li>**锁消除(Lock Elimination)**：通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本地Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)</li></ul><p>JVM会判断再一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那JVM就把它们当作栈上数据对待，认为这些数据时线程独有的，不需要加同步。此时就会进行锁消除<br>​当然在实际开发中，我们很清楚的知道那些地方时线程独有的，不需要加同步锁，但是在Java API中有很多方法都是加了同步的，</p><ul><li>**轻量级锁(Lightweight Locking)**：假设大部分代码处于无锁竞争，避免调用操作系统层面的重量级互斥锁取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒<br><img src="https://user-images.githubusercontent.com/58756074/139001269-55778675-ad21-44ff-beb9-3cf8de9fd7d8.png" alt="轻量级锁CAS操作之前堆栈和对象状态"><br>HotSpot虚拟机中对象头地内存布局（Object header）两部分组成（hashcode，GC Age，锁标志位等（mark world） + 指向方法区对象类型数据的指针（class point））</li></ul><p>加锁：JVM在thread stack中创建一个Lock Record存储object的Mark world的拷贝，JVM使用CAS操作将标记字段Mark Word拷贝到锁记录中，并且将Mark Word更新为指向Lock Record的指针。如果更新成功了，那么这个线程就有用了该对象的锁，并且对象Mark Word的锁标志位更新为(Mark Word中最后的2bit)00，即表示此对象处于轻量级锁定状态。如果更新操作<strong>失败</strong>JVM会去检查Mark Word是否存在指向当前线程的栈帧的指针，如果有，说明该锁已经被获取，可以直接调用。如果没有，则说明该锁被其他线程抢占了，如果有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀位重量级锁，没有获得锁的线程会被阻塞。此时，锁的标志位为10.Mark Word中存储的时指向重量级锁的指针</p><p>解锁：会使用原子的CAS操作将Displaced Mark Word（hcode，GC age，01）替换回到对象头中，如果成功，则表示没有发生竞争关系。如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁:<br><img src="https://user-images.githubusercontent.com/58756074/139001275-cca9ddad-d9d6-476d-ba38-484f9536e049.png" alt="轻量级锁及膨胀流程"></p><ul><li><strong>偏向锁(Biased Locking)</strong>:是为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟<br>当一个线程访问同步快并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁。只需要简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁<br><img src="https://user-images.githubusercontent.com/58756074/139001280-9ed3a25a-e62f-450f-a023-584679a96723.png" alt="偏向锁及轻量级锁"><br>撤销：偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点(就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，让你后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。<br><img src="https://user-images.githubusercontent.com/58756074/139001284-07f4410e-c6c7-425c-82ee-d5a224d81da0.png" alt="偏向锁获得和撤销"></li><li><strong>适应性自旋(Adaptive Spinning)</strong>:当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁(mutex semaphore)前会进入忙等待(Spinning)然<br>后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore(即互斥锁)进入到阻塞状态</li></ul><p><strong>锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)</strong></p><ul><li>自旋锁：当获取锁失败时，不交出cpu使用权，忙等待，如果等待时间不长做线程切换的代价是高于忙等待的代价的</li><li>自适应自旋锁：自旋的时间不再固定了，而是由前一次在同一个锁上的自旋 时间及锁的拥有者的状态来决定的，如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间<h3 id="不同的JDK中对Synchronized有何优化"><a href="#不同的JDK中对Synchronized有何优化" class="headerlink" title="不同的JDK中对Synchronized有何优化"></a>不同的JDK中对Synchronized有何优化</h3>JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用Mutex Lock那么将严重的影响程序的性能<br>在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异地多活</title>
    <link href="/2021/10/22/%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/"/>
    <url>/2021/10/22/%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="系统可用性"><a href="#系统可用性" class="headerlink" title="系统可用性"></a>系统可用性</h3><p>好的软件架构：</p><ol><li>高性能 （延迟低）</li><li>高可用  </li><li>易拓展  (迭代新功能成本低)</li></ol><p>高可用：</p><ul><li><p><strong>平均故障间隔 MTBF（Mean Time Between Failure）</strong>：表示两次故障的间隔时间，也就是系统「正常运行」的平均时间，这个时间越长，说明系统稳定性越高</p></li><li><p><strong>故障恢复时间 MTTR（Mean Time To Repair）</strong>：表示系统发生故障后「恢复的时间」，这个值越小，故障对用户的影响越小</p></li></ul><p><strong>可用性（Availability）= MTBF / (MTBF + MTTR) * 100%</strong></p><p><img src="https://user-images.githubusercontent.com/58756074/138387511-ffcaf080-f779-41f1-851d-394b2c6e19be.jpg" alt="N个9"></p><h3 id="单机架构"><a href="#单机架构" class="headerlink" title="单机架构"></a>单机架构</h3><p>应用直接读写数据库，但需要注意的是，这里的数据库是「单机」部署的，所以它有一个致命的缺点：一旦遭遇意外，例如磁盘损坏、操作系统异常、误删数据，那这意味着所有数据就全部「丢失」了，这个损失是巨大的。</p><p>解决方法备份的问题：</p><ol><li><strong>恢复需要时间</strong>：业务需先停机，再恢复数据，停机时间取决于恢复的速度，恢复期间服务「不可用」</li><li><strong>数据不完整</strong>：因为是定期备份，数据肯定不是「最新」的，数据完整程度取决于备份的周期<br>很明显，你的数据库越大，意味故障恢复时间越久。那按照前面我们提到的「高可用」标准，这个方案可能连 1 个 9 都达不到，远远无法满足我们对可用性的要求。</li></ol><h3 id="主从副本"><a href="#主从副本" class="headerlink" title="主从副本"></a>主从副本</h3><p>你可以在另一台机器上，再部署一个数据库实例，让这个新实例成为原实例的「副本」，让两者保持「实时同步」</p><p>master-slave优点：</p><ul><li><strong>数据完整性高</strong>：主从副本实时同步，数据「差异」很小</li><li><strong>抗故障能力提升</strong>：主库有任何异常，从库可随时「切换」为主库，继续提供服务</li><li><strong>读性能提升</strong>：业务应用可直接读从库，分担主库「压力」读压力</li></ul><p>这个方案不错，不仅大大提高了数据库的可用性，还提升了系统的读性能，同样的思路，你的「业务应用」也可以在其它机器部署一份，避免单点。因为业务应用通常是「无状态」的（不像数据库那样存储数据），所以直接部署即可，非常简单。</p><p>因为业务应用部署了多个，所以你现在还需要部署一个「接入层」，来做请求的「负载均衡」（一般会使用 nginx 或 LVS），这样当一台机器宕机后，另一台机器也可以「接管」所有流量，持续提供服务。</p><p><strong>冗余</strong>是设计核心</p><h3 id="风险不可控"><a href="#风险不可控" class="headerlink" title="风险不可控"></a>风险不可控</h3><p>而一个机房有很多服务器，这些服务器通常会分布在一个个「机柜」上，如果你使用的这些机器，刚好在一个机柜，还是存在风险。就算不在同一机柜也在同一个环境下：机房</p><p>例子：</p><ul><li>杭州市某地光纤被挖断，近 3 亿用户长达 5 小时无法访问支付宝</li><li>B 站部分服务器机房发生故障，造成整站持续 3 个小时无法访问（印象深刻）</li><li>富途证券服务器机房发生电力闪断故障，造成用户 2 个小时无法登陆、交易</li></ul><p>对付机房基本的问题还是冗余</p><h3 id="同城灾备"><a href="#同城灾备" class="headerlink" title="同城灾备"></a>同城灾备</h3><p>机房备份 （冷备：B 机房只做备份，不提供实时服务，它是冷的，只会在 A 机房故障时才会启用）但备份的问题依旧和之前描述的一样：数据不完整、恢复数据期间业务不可用，整个系统的可用性还是无法得到保证</p><p>主从副本：</p><ol><li>B 机房所有从库提升为主库</li><li>在 B 机房部署应用，启动服务</li><li>部署接入层，配置转发规则</li><li>DNS 指向 B 机房，接入流量，业务恢复</li></ol><p>因此，要想缩短业务恢复的时间，你必须把这些工作在 B 机房「提前」做好，也就是说，你需要在 B 机房提前部署好接入层、业务应用，等待随时切换。架构就变成了这样：</p><p>这样只有两件事： B 机房所有从库提升为主库 和 DNS 指向 B 机房，接入流量，业务恢复<br><strong>热备份</strong>：随时可切换<br><img src="https://user-images.githubusercontent.com/58756074/138390185-bf5c3486-3703-4802-b3b2-37deb48cc3da.jpg" alt="热备份"></p><h3 id="同城双活"><a href="#同城双活" class="headerlink" title="同城双活"></a>同城双活</h3><p>让B机房也接入流量通过DNS，单纯在故障时使用有点浪费，平时还可以分流<br>从库readonly，<strong>读写分离</strong>即两个机房的「读」流量，可以读任意机房的存储，但「写」流量，只允许写 A 机房，因为主库在 A 机房。</p><p>两个机房部署在「同城」，物理距离比较近，而且两个机房用「专线」网络连接，虽然跨机房访问的延迟，比单个机房内要大一些，但整体的延迟还是可以接受的。</p><h3 id="两地三中心"><a href="#两地三中心" class="headerlink" title="两地三中心"></a>两地三中心</h3><p>两个机房还是在同一个城市，接着冗余，建议两个机房的距离要在 1000 公里以上，这样才能应对城市级别的灾难。<br><strong>两地是指 2 个城市，三中心是指有 3 个机房，其中 2 个机房在同一个城市，并且同时提供服务，第 3 个机房部署在异地，只做数据灾备</strong></p><h3 id="伪异地双活"><a href="#伪异地双活" class="headerlink" title="伪异地双活"></a>伪异地双活</h3><p>跨城专线带来的网络延迟，因为两个机房距离较远，受到物理距离的限制，现在，两地之间的网络延迟就变成了「不可忽视」的因素了。</p><h3 id="真正的异地双活"><a href="#真正的异地双活" class="headerlink" title="真正的异地双活"></a>真正的异地双活</h3><p>两个机房的存储必须都是「主库」，而且两个机房的数据还要「互相同步」数据，即客户端无论写哪一个机房，都能把这条数据同步到另一个机房。<br>因为只有两个机房都拥有「全量数据」，才能支持任意切换机房，持续提供服务。</p><p>MySQL 本身就提供了双主架构，它支持双向复制数据，但平时用的并不多。而且 Redis、MongoDB 等数据库并没有提供这个功能，所以，你必须开发对应的「数据同步中间件」来实现双向同步的功能。</p><p>这样可能会带来数据冲突，数据没有在对方机房里同步时</p><p>一种方法：数据同步中间件要有自动「合并」数据、解决「冲突」的能力如依赖时钟，但这种方案需要两个机房的「时钟」严格保持一致才行，否则很容易出现问题</p><h3 id="如何实施异地双活"><a href="#如何实施异地双活" class="headerlink" title="如何实施异地双活"></a>如何实施异地双活</h3><p><strong>在最上层接入流量时，就不要让冲突的情况发生</strong> 避免跨机房 路由规则有三类</p><ol><li><p>按业务类型分片<br>假设我们一共有 4 个应用，北京和上海机房都部署这些应用。但应用 1、2 只在北京机房接入流量，在上海机房只是热备。应用 3、4 只在上海机房接入流量，在北京机房是热备。</p></li><li><p>直接哈希分片<br>这种方案就是，最上层的路由层，会根据用户 ID 计算「哈希」取模，然后从路由表中找到对应的机房，之后把请求转发到指定机房内。</p></li><li><p>按地理位置分片<br>这种方案，非常适合与地理位置密切相关的业务，例如打车、外卖服务就非常适合这种方案。<br>北京、河北地区的用户点餐，请求只会打到北京机房，而上海、浙江地区的用户，请求则只会打到上海机房。这样的分片规则，也能避免数据冲突。</p></li></ol><p><strong>让同一个用户的相关请求，只在一个机房内完成所有业务「闭环」，不再出现「跨机房」访问</strong></p><p>现在，两个机房就可以都接收「读写」流量（做好分片的请求），底层存储保持「双向」同步，两个机房都拥有全量数据，当任意机房故障时，另一个机房就可以「接管」全部流量，实现快速切换</p><p>不仅如此，因为机房部署在异地，我们还可以更细化地「优化」路由规则，让用户访问就近的机房，这样整个系统的性能也会大大提升。</p><h3 id="异地多活"><a href="#异地多活" class="headerlink" title="异地多活"></a>异地多活</h3><p>服务按照「单元化」的部署方式，可以让每个机房部署在任意地区，随时扩展新机房，你只需要在最上层定义好分片规则就好了。<br>但这里还有一个小问题，随着扩展的机房越来越多，当一个机房写入数据后，需要同步的机房也越来越多，这个实现复杂度会比较高。</p><p><img src="https://user-images.githubusercontent.com/58756074/138391560-2d8b5f9b-c729-455f-bea5-f224df6e7dd5.jpg" alt="异地多活"></p><p>这种方案必须设立一个「中心机房」，任意机房写入数据后，都只同步到中心机房，再由中心机房同步至其它机房，一个机房写入数据，只需要同步数据到中心机房即可，不需要再关心一共部署了多少个机房，实现复杂度大大「简化」。</p><p>但与此同时，这个中心机房的「稳定性」要求会比较高。不过也还好，即使中心机房发生故障，我们也可以把任意一个机房，提升为中心机房，继续按照之前的架构提供服务。</p><p><strong>可以任意扩展机房「就近」部署。任意机房发生故障，可以完成快速「切换」</strong></p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内核接收网络包</title>
    <link href="/2021/10/22/%E5%86%85%E6%A0%B8%E6%8E%A5%E6%94%B6%E7%BD%91%E7%BB%9C%E5%8C%85/"/>
    <url>/2021/10/22/%E5%86%85%E6%A0%B8%E6%8E%A5%E6%94%B6%E7%BD%91%E7%BB%9C%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="到达网卡"><a href="#到达网卡" class="headerlink" title="到达网卡"></a>到达网卡</h3><p>网卡接收网络包并存放在网卡内的缓冲区，实质上就是把网线中的高低电平，转换到网卡上的一个缓冲区中存储着</p><p>再由网卡缓冲区加载到内存缓冲区通过DMA，这个过程的前提是，<strong>网卡驱动</strong>需要在内存中申请一个缓冲区叫 <strong>sk_buffer</strong>，然后把这个 sk_buffer 的地址告诉网卡，这样 DMA 才知道等网卡的缓冲区有数据到来时，把它拷贝到内存的什么位置上。</p><h3 id="网卡发出中断（硬中断）"><a href="#网卡发出中断（硬中断）" class="headerlink" title="网卡发出中断（硬中断）"></a>网卡发出中断（硬中断）</h3><p>网卡向 CPU 发起中断信号，CPU 打断当前的程序，根据中断号找到中断处理程序，开始执行。<br>硬中断几乎啥也没干，将网卡设备 dev 放入 poll_list 里，然后立刻发起了一次软中断，然后就结束了。<br>这是为了尽快响应硬中断，以便计算机可以尽快处理下一个硬中断，毕竟鼠标点击、键盘敲击等需要响应特别及时。而像网络包到来后的拷贝和解析过程，在硬中断面前优先级没那么高，所以就触发一个软中断等着内核线程去执行就好了。</p><h3 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h3><p>软中断遍历 poll_list 取出一个个的设备 dev，然后调用其 poll 函数，移步IP网络层拿到IP包再交给上传传输层拿到TCP包解析出来的数据，由应用程序去接受和处理，就是我们的 socket bind listen read 的流程了</p><p>我们常说协议栈不断去掉头部，交给上层协议栈处理，这句话在代码层面其实就是网络层协议解析的方法 ip_rcv 里的末尾调用了传输层协议解析的方法 tcp_v4_rcv，仅此而已。</p><p>而说 Linux 处理中断是分上半部和下半部的方案，代码层面就是硬中断处理函数的代码里，直接发起一个软中断，然后便返回，仅此而已。</p><p><img src="https://user-images.githubusercontent.com/58756074/138385642-d9d7800a-e375-45fb-b4ab-4d6d7be9e052.png" alt="网络包到应用程序"></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中断</title>
    <link href="/2021/10/21/%E4%B8%AD%E6%96%AD/"/>
    <url>/2021/10/21/%E4%B8%AD%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>内核接收网络包的起点就是中断（硬中断和软中断）</p><h3 id="整个操作系统就是一个中断驱动的死循环"><a href="#整个操作系统就是一个中断驱动的死循环" class="headerlink" title="整个操作系统就是一个中断驱动的死循环"></a>整个操作系统就是一个中断驱动的死循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    doNothing();<br>&#125;<br></code></pre></td></tr></table></figure><p>其他所有事情都是由操作系统提前注册的中断机制和其对应的中断处理函数完成，我们点击一下鼠标，敲击一下键盘，执行一个程序，都是用中断的方式来通知操作系统帮我们处理这些事件，当没有任何需要操作系统处理的事件时，它就乖乖停在死循环里不出来。</p><h3 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h3><ul><li><p>中断 interrupts</p></li><li><p>异常 exception</p><ul><li>故障 faults</li><li>陷阱 traps</li><li>终止 aborts</li></ul></li></ul><p>CPU 提供了两种中断（verb）程序执行的机制，中断和异常。</p><p>先说第一个机制中断（interrupt），中断是一个异步事件，通常由 IO 设备触发。比如点击一下鼠标、敲击一下键盘等。</p><p>再说第二个机制异常（exception），异常是一个同步事件，是 CPU 在执行指令时检测到的反常条件。比如除法异常、错误指令异常，缺页异常等。</p><p>这两个机制，殊途同归，都是让 CPU 收到一个中断号</p><p>除上两种机制外，还有一种方式可以给到 CPU 一个中断号，INT指令（比如 INT 0x80，就是告诉 CPU 中断号是 0x80。Linux 内核提供的系统调用，就是用了 INT 0x80 这种指令）</p><p>有的地方喜欢把他们做一些区分，把 INT n 这种方式叫做软件中断，因为他是由软件程序主动触发的。相应的把上面的中断和异常叫做硬件中断，因为他们都是硬件自动触发的。</p><h3 id="给-CPU-一个中断号有三种方式"><a href="#给-CPU-一个中断号有三种方式" class="headerlink" title="给 CPU 一个中断号有三种方式"></a>给 CPU 一个中断号有三种方式</h3><ol><li><p><strong>通过中断控制器给 CPU 的 INTR 引脚发送信号</strong>，并且允许 CPU 从中断控制器的一个端口上读取中断号，比如按下键盘的一个按键，最终会给到 CPU 一个 0x21 中断号。</p></li><li><p><strong>CPU 执行某条指令发现了异常</strong>，会自己触发并给自己一个中断号，比如执行到了无效指令，CPU 会给自己一个 0x06 的中断号。</p></li><li><p><strong>执行 INT n 指令</strong>，会直接给 CPU 一个中断号 n，比如触发了 Linux 的系统调用，实际上就是执行了 INT 0x80 指令，那么 CPU 收到的就是一个 0x80 中断号。</p></li></ol><h3 id="CPU接收中断号后"><a href="#CPU接收中断号后" class="headerlink" title="CPU接收中断号后"></a>CPU接收中断号后</h3><p><strong>Roughly：CPU 收到一个中断号 n 后，会去中断向量表中寻找第 n 个中断描述符，从中断描述符中找到中断处理程序的地址，然后跳过去执行</strong></p><p>为什么说不准确这又涉及到操作系统的段式内存（段选因子+offset）通过段选因子找到段基址然后配合offset找到程序入口</p><ul><li><p>中断描述表（Interrupt Descriptor Table）就是一个在内存中的数组而已</p></li><li><p>中断描述符（desc_struct）就是中断描述符表这个数组里的存储的数据结构</p></li></ul><p>CPU通过IDTR寄存器找到IDT</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>现在这些都是硬中断（硬件完成的中断），当然这里也要有软件的配合，比如软件需要提前把中断向量表写在内存里，并通过 IDTR 寄存器告诉 CPU 它的起始位置在哪里。</p><p><strong>软中断是纯粹由软件实现的一种类似中断的机制</strong>，实际上它就是模仿硬件，在内存中有一个地方存储着软中断的标志位，然后由内核的一个线程不断轮询这些标志位，如果有哪个标志位有效，则再去另一个地方寻找这个软中断对应的中断处理程序。</p><h3 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h3><p>软中断是纯软件实现的，也是打断当前正在运行的程序，转而去执行中断处理程序，执行完之后再返回原程序。</p><p>硬中断的微观层面，就是 CPU 在每一个指令周期的最后，都会留一个 CPU 周期去查看是否有中断，如果有，就把中断号取出，去中断向量表中寻找中断处理程序，然后跳过去。</p><p>软中断的微观层面，简单说就是有一个<strong>单独的守护进程</strong>，不断轮询一组<strong>标志位</strong>，如果哪个标志位有值了，那去这个标志位对应的<strong>软中断向量表数组</strong>的相应位置，找到软中断处理函数，然后跳过去。</p><h3 id="开启内核软中断处理的守护进程"><a href="#开启内核软中断处理的守护进程" class="headerlink" title="开启内核软中断处理的守护进程"></a>开启内核软中断处理的守护进程</h3><p><img src="https://user-images.githubusercontent.com/58756074/138382715-f06ca2c9-5d4b-49ef-9cd0-0fcba5f78076.png" alt="Linux开机过程"></p><p>start_kernel: rest_init: 开启内核软中断守护进程</p><p>软中断向量表 softirq_vec，就是个数组嘛，然后里面的元素存储着软中断处理程序的地址指针</p><p><strong>不断遍历 pending 这个软中断标志位的每一位，如果是 0 就忽略，如果是 1，那从上面的 h 软中断向量表中找到对应的元素，然后执行 action 方法，action 就对应着不同的软中断处理函数</strong></p><h3 id="软中断两步走"><a href="#软中断两步走" class="headerlink" title="软中断两步走"></a>软中断两步走</h3><ol><li><p><strong>注册软中断向量表</strong>，其实就是把软中断向量表的每个 action 变量赋值，相当于硬中断中注册中断向量表的过程。<br>比如，<strong>网络子系统的初始化</strong>，有一步就需要<strong>注册网络的软中断处理函数</strong>。</p></li><li><p><strong>触发一个软中断</strong>，其实就是修改 pending 的某个标志位，触发一次软中断，相当于硬中断中由外部硬件、异常、或者 INT 指令来触发硬中断一样。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>软中断是 Linux 处理一个中断的下半部的主要方式</strong>，比如 Linux 某网卡接收了一个数据包，此时会触发一个硬中断，由于处理数据包的过程比较耗时，而硬中断资源又非常宝贵，如果占着硬中断函数不返回，会影响到其他硬中断的相应速度，比如点击鼠标、按下键盘等。</p><p>所以一般 Linux 会把中断分成**上下两半部分执行，上半部分处理最简单的逻辑，下半部分直接丢给一个软中断异步处理。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interrupt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown</title>
    <link href="/2021/10/20/Markdown/"/>
    <url>/2021/10/20/Markdown/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这是一级标题</span><br><span class="hljs-comment">## 这是二级标题</span><br><span class="hljs-comment">### 这是三级标题</span><br><span class="hljs-comment">#### 这是四级标题</span><br><span class="hljs-comment">##### 这是五级标题</span><br><span class="hljs-comment">###### 这是六级标题</span><br></code></pre></td></tr></table></figure><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">**这是加粗的文字**<br>*这是倾斜的文字*`<br>***这是斜体加粗的文字***<br>~~这是加删除线的文字~~<br></code></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;这是引用的内容<br>&gt;&gt;这是引用的内容<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容<br></code></pre></td></tr></table></figure><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">---<br>----<br>***<br>*****<br></code></pre></td></tr></table></figure><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">![图片alt](图片地址 <span class="hljs-string">&#x27;&#x27;</span>图片title<span class="hljs-string">&#x27;&#x27;</span>)<br><br>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。<br>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加<br></code></pre></td></tr></table></figure><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[超链接名](超链接地址 <span class="hljs-string">&quot;超链接title&quot;</span>)<br>title可加可不加<br></code></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">- 列表内容<br>+ 列表内容<br>* 列表内容<br><br>注意：- + * 跟内容之间都要有一个空格<br><br>1. 列表内容<br>2. 列表内容<br>3. 列表内容<br><br>注意：序号跟内容之间要有空格<br><br></code></pre></td></tr></table></figure><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">上一级和下一级之间敲三个空格即可<br>- 列表<br>   - 二级列表<br>   - 二级列表<br></code></pre></td></tr></table></figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">表头|表头|表头<br>---|:--:|---:<br>内容|内容|内容<br>内容|内容|内容<br><br>|  表头   | 表头  |<br>|  ----  | ----  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |<br><br>| 左对齐 | 右对齐 | 居中对齐 |<br>| :-----| ----: | :----: |<br>| 单元格 | 单元格 | 单元格 |<br>| 单元格 | 单元格 | 单元格 |<br><br>第二行分割表头和内容。<br>- 有一个就行，为了对齐，多加了几个<br>文字默认居左<br>-两边加：表示文字居中<br>-右边加：表示文字居右<br>注：原生的语法两边都要用 | 包起来。此处省略<br></code></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">单行     `代码内容`<br>(```)<br>  代码...<br>  代码...<br>  代码...<br>(```)<br>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。<br></code></pre></td></tr></table></figure><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">```flow<br>st=&gt;start: 开始<br>op=&gt;operation: My Operation<br>cond=&gt;condition: Yes or No?<br>e=&gt;end<br>st-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;op<br>&amp;`<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hosts File</title>
    <link href="/2021/10/20/Hosts-File/"/>
    <url>/2021/10/20/Hosts-File/</url>
    
    <content type="html"><![CDATA[<p>Hosts file是将域名和IP建立mapping，相当于DNS缓存，浏览器会先优先在hosts里查找IP，如果没有则系统再将网址提交DNS域名解析服务器进行解析</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="TBA"><a href="#TBA" class="headerlink" title="TBA"></a>TBA</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /etc<br>$ vim hosts<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hosts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Two Git Accounts On One Device</title>
    <link href="/2021/10/20/Two-Git-Accounts-On-One-Device/"/>
    <url>/2021/10/20/Two-Git-Accounts-On-One-Device/</url>
    
    <content type="html"><![CDATA[<p>This blog will discuss how to maintain two github accounts on one device.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Generate-SSH-keys"><a href="#Generate-SSH-keys" class="headerlink" title="Generate SSH keys"></a>Generate SSH keys</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;email address&quot;</span><br></code></pre></td></tr></table></figure><p>Note:</p><p>-b specify the size of keyfile “bits”</p><p>-t means type should usually be rsa , dsa , ecdsa</p><p>-c means comment Changes the comment for the keyfile</p><h3 id="Register-pub-key-to-github"><a href="#Register-pub-key-to-github" class="headerlink" title="Register pub key to github"></a>Register pub key to github</h3><p>skip (Settings/SSH and GPG)</p><h3 id="Create-a-config-file-at-ssh"><a href="#Create-a-config-file-at-ssh" class="headerlink" title="Create a config file at ~/.ssh"></a>Create a config file at ~/.ssh</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># tw(xiang.li4@thoughtworks.com)</span><br>Host github.com-LiXiang-TW<br>   HostName github.com<br>   User git<br>   IdentityFile ~/.ssh/id_rsa.tw<br>   IdentitiesOnly yes<br><br><span class="hljs-comment"># me(xili7209@gmail.com)</span><br>Host github.com-xili7209<br>   HostName github.com<br>   User git<br>   IdentityFile ~/.ssh/id_rsa.me<br>   IdentitiesOnly yes<br><br></code></pre></td></tr></table></figure><h3 id="Clone-the-repo-replace-github-com-with-github-com-xili7209-LiXiang-TW"><a href="#Clone-the-repo-replace-github-com-with-github-com-xili7209-LiXiang-TW" class="headerlink" title="Clone the repo (replace github.com with github.com-xili7209/LiXiang-TW)"></a>Clone the repo (replace github.com with github.com-xili7209/LiXiang-TW)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> git@github.com-GitId:GitId/your-repo-name.git (your-repo-name_GitId)<br></code></pre></td></tr></table></figure><h3 id="Configure-git-identity"><a href="#Configure-git-identity" class="headerlink" title="Configure git identity"></a>Configure git identity</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[user]<br>    name = git name<br>    email = ***@gmail.com<br></code></pre></td></tr></table></figure><h3 id="Ensure-reomte-url-is-git-remote-set-url-origin-103-x69-x74-64-103-x69-116-104-117-98-46-x63-111-109-x2d-x67-105-x74-x4e-x61-x6d-x65-gitName-your-repo-name-git-your-repo-name-gitName"><a href="#Ensure-reomte-url-is-git-remote-set-url-origin-103-x69-x74-64-103-x69-116-104-117-98-46-x63-111-109-x2d-x67-105-x74-x4e-x61-x6d-x65-gitName-your-repo-name-git-your-repo-name-gitName" class="headerlink" title="Ensure reomte url is git remote set-url origin &#103;&#x69;&#x74;&#64;&#103;&#x69;&#116;&#104;&#117;&#98;&#46;&#x63;&#111;&#109;&#x2d;&#x67;&#105;&#x74;&#x4e;&#x61;&#x6d;&#x65;:gitName/your-repo-name.git (your-repo-name_gitName)"></a>Ensure reomte url is <strong>git remote set-url origin <a href="mailto:&#103;&#x69;&#x74;&#64;&#103;&#x69;&#116;&#104;&#117;&#98;&#46;&#x63;&#111;&#109;&#x2d;&#x67;&#105;&#x74;&#x4e;&#x61;&#x6d;&#x65;">&#103;&#x69;&#x74;&#64;&#103;&#x69;&#116;&#104;&#117;&#98;&#46;&#x63;&#111;&#109;&#x2d;&#x67;&#105;&#x74;&#x4e;&#x61;&#x6d;&#x65;</a>:gitName/your-repo-name.git (your-repo-name_gitName)</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[remote <span class="hljs-string">&quot;origin&quot;</span>] <br>       url = git@github.com-gitName:gitName/your-repo-name.git<br>       fetch = +refs/heads/*:refs/remotes/origin/*<br></code></pre></td></tr></table></figure><p>More info: <a href="https://gist.github.com/Jonalogy/54091c98946cfe4f8cdab2bea79430f9">Handle_Multi_GitAccount</a></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Terminal-ShortCut</title>
    <link href="/2021/10/20/Terminal-ShortCut/"/>
    <url>/2021/10/20/Terminal-ShortCut/</url>
    
    <content type="html"><![CDATA[<p>终端快捷键</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash">Ctrl+a：光标回到命令行首。 （a：ahead）<br><br>Ctrl+a：光标回到命令行首。 （a：ahead）<br><br>Ctrl+e：光标回到命令行尾。 （e：end）<br><br>Ctrl+b：光标向行首移动一个字符。 （b：backwards）<br><br>Ctrl+ f：光标向行尾移动一个字符。 （f：forwards）<br><br>Ctrl+w: 删除光标处到行首的字符。<br><br>Ctrl+k：删除光标处到行尾的字符。<br><br>Ctrl+u：删除整个命令行文本字符。<br><br>Ctrl+h：向行首删除一个字符。<br><br>Ctrl+d：向行尾删除一个字符。<br><br>Ctrl+y:：粘贴Ctrl+u，Ctrl+k，Ctrl+w删除的文本。<br><br>Ctrl+p: 上一个使用的历史命令。 （p：previous）<br><br>Ctrl+n： 下一个使用的历史命令。（n：next ）<br><br>Ctrl+r：快速检索历史命令。（r：retrieve）。<br><br>Ctrl+t： 交换光标所在字符和其前的字符。<br><br>Ctrl+i：相当于Tab键。<br><br>Ctrl+o：相当于Ctrl+m.<br><br>Ctrl+m：相当Enter键。<br></code></pre></td></tr></table></figure><h3 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">Ctrl+s:使终端发呆，静止，可以使快速输出的终端屏幕停下来。<br><br>Ctrl+q：退出Ctrl+s引起的发呆。<br><br>Ctrl+z：使正在运行在终端的任务，运行于后台。 （可用<span class="hljs-built_in">fg</span>恢复）<br><br>Ctrl+c：中断终端中正在执行的任务。<br><br>Ctrl+d: 在空命令行的情况下可以退出终端。<br><br>Ctrl+[ ：相当于Esc键。<br><br>Esc键：连续按3次显示所有的支持的终端命令。<br><br>Tab键：命令、文件名等自动补全功能。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shortcut</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/10/20/hello-world/"/>
    <url>/2021/10/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate  <span class="hljs-comment">#hexo g</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy  <span class="hljs-comment">#hexo d</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="Hexo-Clean-amp-amp-Hexo-Deploy"><a href="#Hexo-Clean-amp-amp-Hexo-Deploy" class="headerlink" title="Hexo Clean &amp;&amp; Hexo Deploy"></a>Hexo Clean &amp;&amp; Hexo Deploy</h3><p>Note: 部署需要注意congfig.yml里deploy下仓库格式：<a href="mailto:&#x67;&#105;&#116;&#64;&#x67;&#105;&#116;&#x68;&#x75;&#98;&#46;&#x63;&#111;&#109;">&#x67;&#105;&#116;&#64;&#x67;&#105;&#116;&#x68;&#x75;&#98;&#46;&#x63;&#111;&#109;</a>:liuxianan/liuxianan.github.io.git（不要用https）</p><h3 id="注意front-matter（—）页面格式内容应该在front-matter内编辑"><a href="#注意front-matter（—）页面格式内容应该在front-matter内编辑" class="headerlink" title="注意front matter（—）页面格式内容应该在front matter内编辑"></a>注意front matter（—）页面格式内容应该在front matter内编辑</h3>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
