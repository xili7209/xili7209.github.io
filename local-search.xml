<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>synchronized</title>
    <link href="/2021/10/27/synchronized/"/>
    <url>/2021/10/27/synchronized/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Synchronized可以作用在哪里-分别通过对象锁和类锁进行举例"><a href="#Synchronized可以作用在哪里-分别通过对象锁和类锁进行举例" class="headerlink" title="Synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例"></a>Synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例</h3><p>Ans：对象锁分为方法锁和同步块锁，其中方法锁默认作用于当前实例也就是this，同步块代码锁则是自定义锁。类锁则是指synchronized的方法锁作用在静态方法上或者是类上，这类锁无论多少线程访问都只有一把锁。</p><ul><li>对象锁 (默认this,指定对象)</li></ul><p>包括方法锁(默认锁对象为this,当前实例对象)和同步代码块锁(自己指定锁对象)</p><p><strong>代码块形式：手动指定锁定对象，也可是是this,也可以是自定义的锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instance = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 同步代码块形式——锁为this,两个线程使用的锁是一样的,线程1必须要等到线程0释放了该锁后，才能执行</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(instance);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(instance);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*output：</span><br><span class="hljs-comment">我是线程Thread-0</span><br><span class="hljs-comment">Thread-0结束</span><br><span class="hljs-comment">我是线程Thread-1</span><br><span class="hljs-comment">Thread-1结束</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instence = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br>    <span class="hljs-comment">// 创建2把锁</span><br>    Object block1 = <span class="hljs-keyword">new</span> Object();<br>    Object block2 = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 这个代码块使用的是第一把锁，当他释放后，后面的代码块由于使用的是第二把锁，因此可以马上执行</span><br>        <span class="hljs-keyword">synchronized</span> (block1) &#123;<br>            System.out.println(<span class="hljs-string">&quot;block1锁,我是线程&quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;block1锁,&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (block2) &#123;<br>            System.out.println(<span class="hljs-string">&quot;block2锁,我是线程&quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;block2锁,&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(instence);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(instence);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*output：</span><br><span class="hljs-comment">block1锁,我是线程Thread-0</span><br><span class="hljs-comment">block1锁,Thread-0结束</span><br><span class="hljs-comment">block2锁,我是线程Thread-0　　// 可以看到当第一个线程在执行完第一段同步代码块之后，第二个同步代码块可以马上得到执行，因为他们使用的锁不是同一把</span><br><span class="hljs-comment">block1锁,我是线程Thread-1</span><br><span class="hljs-comment">block2锁,Thread-0结束</span><br><span class="hljs-comment">block1锁,Thread-1结束</span><br><span class="hljs-comment">block2锁,我是线程Thread-1</span><br><span class="hljs-comment">block2锁,Thread-1结束</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>方法锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instence = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        method();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(instence);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(instence);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*output：</span><br><span class="hljs-comment">我是线程Thread-0</span><br><span class="hljs-comment">Thread-0结束</span><br><span class="hljs-comment">我是线程Thread-1</span><br><span class="hljs-comment">Thread-1结束</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li>类锁 （指synchronize修饰静态的方法或指定锁对象为Class对象）</li></ul><p>静态方法都属于类所以无论是修饰静态方法还是指定对象为class，哪个线程访问它，需要的锁都只有一把</p><h3 id="Synchronized本质上是通过什么保证线程安全的-分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理"><a href="#Synchronized本质上是通过什么保证线程安全的-分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理" class="headerlink" title="Synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理"></a>Synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理</h3><p>Ans: 通过Monitor来控制线程对对象的访问，同一时间一个对象只能和一个monitor关联而一个monitor在同一时间只能被一个线程获得，monitor保证了互斥并且锁是可重入的当线程获取该对象锁后，计数器+1，释放-1，当计时器为0时下一个线程可以从同步队列中获取锁。通过sychronized的happens-before，对同一个监视器的解锁，happens-before于对该监视器的加锁即先进入修改线程的结果对后来的线程是可见的</p><ul><li>加锁和释放锁的原理</li></ul><p>Monitor：通过反编译可以看到有这么两个指令<strong>monitorenter，monitorexit</strong></p><p>monitorenter：</p><ul><li>monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待</li><li>如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加</li><li>这把锁已经被别的线程获取了，等待锁释放</li></ul><p>monitorexit：<br>释放对于monitor的所有权，释放过程很简单，就是讲monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁</p><p><img src="https://user-images.githubusercontent.com/58756074/138994203-9d01a992-aa14-4427-941f-f55a0ebc81e4.png" alt="java-thread-x-key-schronized-2"><br><strong>可重入原理：加锁次数计数器</strong><br>Synchronized先天具有重入性。每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一</p><p><strong>保证可见性的原理：内存模型和happens-before规则</strong><br>Synchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁</p><h3 id="Synchronized有什么样的缺陷-Java-Lock是怎么弥补这些缺陷的"><a href="#Synchronized有什么样的缺陷-Java-Lock是怎么弥补这些缺陷的" class="headerlink" title="Synchronized有什么样的缺陷? Java Lock是怎么弥补这些缺陷的"></a>Synchronized有什么样的缺陷? Java Lock是怎么弥补这些缺陷的</h3><p>Ans：TODO</p><p>JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用Mutex Lock那么将严重的影响程序的性能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">N/A<br></code></pre></td></tr></table></figure><h3 id="Synchronized和Lock的对比，和选择"><a href="#Synchronized和Lock的对比，和选择" class="headerlink" title="Synchronized和Lock的对比，和选择"></a>Synchronized和Lock的对比，和选择</h3><p>Ans：在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错</p><h3 id="Synchronized在使用时有何注意事项"><a href="#Synchronized在使用时有何注意事项" class="headerlink" title="Synchronized在使用时有何注意事项?"></a>Synchronized在使用时有何注意事项?</h3><ul><li>锁对象不能为空，因为锁的信息都保存在对象头里</li><li>避免死锁</li><li>作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错</li><li>在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错</li></ul><h3 id="Synchronized修饰的方法在抛出异常时-会释放锁吗"><a href="#Synchronized修饰的方法在抛出异常时-会释放锁吗" class="headerlink" title="Synchronized修饰的方法在抛出异常时,会释放锁吗"></a>Synchronized修饰的方法在抛出异常时,会释放锁吗</h3><p>Ans：synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁</p><h3 id="多个线程等待同一个synchronized锁的时候，JVM如何选择下一个获取锁的线程"><a href="#多个线程等待同一个synchronized锁的时候，JVM如何选择下一个获取锁的线程" class="headerlink" title="多个线程等待同一个synchronized锁的时候，JVM如何选择下一个获取锁的线程"></a>多个线程等待同一个synchronized锁的时候，JVM如何选择下一个获取锁的线程</h3><p>多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。高并发的情况下会导致性能下降。</p><h3 id="Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法"><a href="#Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法" class="headerlink" title="Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法"></a>Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法</h3><h3 id="我想更加灵活地控制锁的释放和获取-现在释放锁和获取锁的时机都被规定死了-，怎么办"><a href="#我想更加灵活地控制锁的释放和获取-现在释放锁和获取锁的时机都被规定死了-，怎么办" class="headerlink" title="我想更加灵活地控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办"></a>我想更加灵活地控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办</h3><p>Synchronized只有锁只与一个条件(是否获取锁)相关联，不灵活，后来Condition与Lock的结合解决了这个问题。</p><h3 id="什么是锁的升级和降级-什么是JVM里的偏向锁、轻量级锁、重量级锁"><a href="#什么是锁的升级和降级-什么是JVM里的偏向锁、轻量级锁、重量级锁" class="headerlink" title="什么是锁的升级和降级? 什么是JVM里的偏向锁、轻量级锁、重量级锁"></a>什么是锁的升级和降级? 什么是JVM里的偏向锁、轻量级锁、重量级锁</h3><p>Ans：升级也就是在出现竞争时轻量级锁已经无法满足得膨胀至重量锁，降级是在同步块内的数据没有逃逸风险只会被当前线程使用，不需要同步从而进行锁的消除</p><p>jdk 1.6引入大量实现优化：</p><ul><li>**锁粗化(Lock Coarsening)**：（多次上锁变为一次大范围锁）也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁</li><li>**锁消除(Lock Elimination)**：通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本地Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)</li></ul><p>JVM会判断再一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那JVM就把它们当作栈上数据对待，认为这些数据时线程独有的，不需要加同步。此时就会进行锁消除<br>​当然在实际开发中，我们很清楚的知道那些地方时线程独有的，不需要加同步锁，但是在Java API中有很多方法都是加了同步的，</p><ul><li>**轻量级锁(Lightweight Locking)**：假设大部分代码处于无锁竞争，避免调用操作系统层面的重量级互斥锁取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒<br><img src="https://user-images.githubusercontent.com/58756074/139001269-55778675-ad21-44ff-beb9-3cf8de9fd7d8.png" alt="轻量级锁CAS操作之前堆栈和对象状态"><br>HotSpot虚拟机中对象头地内存布局（Object header）两部分组成（hashcode，GC Age，锁标志位等（mark world） + 指向方法区对象类型数据的指针（class point））</li></ul><p>加锁：JVM在thread stack中创建一个Lock Record存储object的Mark world的拷贝，JVM使用CAS操作将标记字段Mark Word拷贝到锁记录中，并且将Mark Word更新为指向Lock Record的指针。如果更新成功了，那么这个线程就有用了该对象的锁，并且对象Mark Word的锁标志位更新为(Mark Word中最后的2bit)00，即表示此对象处于轻量级锁定状态。如果更新操作<strong>失败</strong>JVM会去检查Mark Word是否存在指向当前线程的栈帧的指针，如果有，说明该锁已经被获取，可以直接调用。如果没有，则说明该锁被其他线程抢占了，如果有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀位重量级锁，没有获得锁的线程会被阻塞。此时，锁的标志位为10.Mark Word中存储的时指向重量级锁的指针</p><p>解锁：会使用原子的CAS操作将Displaced Mark Word（hcode，GC age，01）替换回到对象头中，如果成功，则表示没有发生竞争关系。如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁:<br><img src="https://user-images.githubusercontent.com/58756074/139001275-cca9ddad-d9d6-476d-ba38-484f9536e049.png" alt="轻量级锁及膨胀流程"></p><ul><li>**偏向锁(Biased Locking)**：是为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟<br>当一个线程访问同步快并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁。只需要简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁<br>！<a href="https://user-images.githubusercontent.com/58756074/139001280-9ed3a25a-e62f-450f-a023-584679a96723.png">偏向锁及轻量级锁</a><br>撤销：偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点(就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，让你后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。<br><img src="https://user-images.githubusercontent.com/58756074/139001284-07f4410e-c6c7-425c-82ee-d5a224d81da0.png" alt="偏向锁获得和撤销"></li><li>**适应性自旋(Adaptive Spinning)**：当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁(mutex semaphore)前会进入忙等待(Spinning)然<br>后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore(即互斥锁)进入到阻塞状态</li></ul><p><strong>锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)</strong></p><ul><li>自旋锁：当获取锁失败时，不交出cpu使用权，忙等待，如果等待时间不长做线程切换的代价是高于忙等待的代价的</li><li>自适应自旋锁：自旋的时间不再固定了，而是由前一次在同一个锁上的自旋 时间及锁的拥有者的状态来决定的，如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间<h3 id="不同的JDK中对Synchronized有何优化"><a href="#不同的JDK中对Synchronized有何优化" class="headerlink" title="不同的JDK中对Synchronized有何优化"></a>不同的JDK中对Synchronized有何优化</h3></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异地多活</title>
    <link href="/2021/10/22/%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/"/>
    <url>/2021/10/22/%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="系统可用性"><a href="#系统可用性" class="headerlink" title="系统可用性"></a>系统可用性</h3><p>好的软件架构：</p><ol><li>高性能 （延迟低）</li><li>高可用  </li><li>易拓展  (迭代新功能成本低)</li></ol><p>高可用：</p><ul><li><p><strong>平均故障间隔 MTBF（Mean Time Between Failure）</strong>：表示两次故障的间隔时间，也就是系统「正常运行」的平均时间，这个时间越长，说明系统稳定性越高</p></li><li><p><strong>故障恢复时间 MTTR（Mean Time To Repair）</strong>：表示系统发生故障后「恢复的时间」，这个值越小，故障对用户的影响越小</p></li></ul><p><strong>可用性（Availability）= MTBF / (MTBF + MTTR) * 100%</strong></p><p><img src="https://user-images.githubusercontent.com/58756074/138387511-ffcaf080-f779-41f1-851d-394b2c6e19be.jpg" alt="N个9"></p><h3 id="单机架构"><a href="#单机架构" class="headerlink" title="单机架构"></a>单机架构</h3><p>应用直接读写数据库，但需要注意的是，这里的数据库是「单机」部署的，所以它有一个致命的缺点：一旦遭遇意外，例如磁盘损坏、操作系统异常、误删数据，那这意味着所有数据就全部「丢失」了，这个损失是巨大的。</p><p>解决方法备份的问题：</p><ol><li><strong>恢复需要时间</strong>：业务需先停机，再恢复数据，停机时间取决于恢复的速度，恢复期间服务「不可用」</li><li><strong>数据不完整</strong>：因为是定期备份，数据肯定不是「最新」的，数据完整程度取决于备份的周期<br>很明显，你的数据库越大，意味故障恢复时间越久。那按照前面我们提到的「高可用」标准，这个方案可能连 1 个 9 都达不到，远远无法满足我们对可用性的要求。</li></ol><h3 id="主从副本"><a href="#主从副本" class="headerlink" title="主从副本"></a>主从副本</h3><p>你可以在另一台机器上，再部署一个数据库实例，让这个新实例成为原实例的「副本」，让两者保持「实时同步」</p><p>master-slave优点：</p><ul><li><strong>数据完整性高</strong>：主从副本实时同步，数据「差异」很小</li><li><strong>抗故障能力提升</strong>：主库有任何异常，从库可随时「切换」为主库，继续提供服务</li><li><strong>读性能提升</strong>：业务应用可直接读从库，分担主库「压力」读压力</li></ul><p>这个方案不错，不仅大大提高了数据库的可用性，还提升了系统的读性能，同样的思路，你的「业务应用」也可以在其它机器部署一份，避免单点。因为业务应用通常是「无状态」的（不像数据库那样存储数据），所以直接部署即可，非常简单。</p><p>因为业务应用部署了多个，所以你现在还需要部署一个「接入层」，来做请求的「负载均衡」（一般会使用 nginx 或 LVS），这样当一台机器宕机后，另一台机器也可以「接管」所有流量，持续提供服务。</p><p><strong>冗余</strong>是设计核心</p><h3 id="风险不可控"><a href="#风险不可控" class="headerlink" title="风险不可控"></a>风险不可控</h3><p>而一个机房有很多服务器，这些服务器通常会分布在一个个「机柜」上，如果你使用的这些机器，刚好在一个机柜，还是存在风险。就算不在同一机柜也在同一个环境下：机房</p><p>例子：</p><ul><li>杭州市某地光纤被挖断，近 3 亿用户长达 5 小时无法访问支付宝</li><li>B 站部分服务器机房发生故障，造成整站持续 3 个小时无法访问（印象深刻）</li><li>富途证券服务器机房发生电力闪断故障，造成用户 2 个小时无法登陆、交易</li></ul><p>对付机房基本的问题还是冗余</p><h3 id="同城灾备"><a href="#同城灾备" class="headerlink" title="同城灾备"></a>同城灾备</h3><p>机房备份 （冷备：B 机房只做备份，不提供实时服务，它是冷的，只会在 A 机房故障时才会启用）但备份的问题依旧和之前描述的一样：数据不完整、恢复数据期间业务不可用，整个系统的可用性还是无法得到保证</p><p>主从副本：</p><ol><li>B 机房所有从库提升为主库</li><li>在 B 机房部署应用，启动服务</li><li>部署接入层，配置转发规则</li><li>DNS 指向 B 机房，接入流量，业务恢复</li></ol><p>因此，要想缩短业务恢复的时间，你必须把这些工作在 B 机房「提前」做好，也就是说，你需要在 B 机房提前部署好接入层、业务应用，等待随时切换。架构就变成了这样：</p><p>这样只有两件事： B 机房所有从库提升为主库 和 DNS 指向 B 机房，接入流量，业务恢复<br><strong>热备份</strong>：随时可切换<br><img src="https://user-images.githubusercontent.com/58756074/138390185-bf5c3486-3703-4802-b3b2-37deb48cc3da.jpg" alt="热备份"></p><h3 id="同城双活"><a href="#同城双活" class="headerlink" title="同城双活"></a>同城双活</h3><p>让B机房也接入流量通过DNS，单纯在故障时使用有点浪费，平时还可以分流<br>从库readonly，<strong>读写分离</strong>即两个机房的「读」流量，可以读任意机房的存储，但「写」流量，只允许写 A 机房，因为主库在 A 机房。</p><p>两个机房部署在「同城」，物理距离比较近，而且两个机房用「专线」网络连接，虽然跨机房访问的延迟，比单个机房内要大一些，但整体的延迟还是可以接受的。</p><h3 id="两地三中心"><a href="#两地三中心" class="headerlink" title="两地三中心"></a>两地三中心</h3><p>两个机房还是在同一个城市，接着冗余，建议两个机房的距离要在 1000 公里以上，这样才能应对城市级别的灾难。<br><strong>两地是指 2 个城市，三中心是指有 3 个机房，其中 2 个机房在同一个城市，并且同时提供服务，第 3 个机房部署在异地，只做数据灾备</strong></p><h3 id="伪异地双活"><a href="#伪异地双活" class="headerlink" title="伪异地双活"></a>伪异地双活</h3><p>跨城专线带来的网络延迟，因为两个机房距离较远，受到物理距离的限制，现在，两地之间的网络延迟就变成了「不可忽视」的因素了。</p><h3 id="真正的异地双活"><a href="#真正的异地双活" class="headerlink" title="真正的异地双活"></a>真正的异地双活</h3><p>两个机房的存储必须都是「主库」，而且两个机房的数据还要「互相同步」数据，即客户端无论写哪一个机房，都能把这条数据同步到另一个机房。<br>因为只有两个机房都拥有「全量数据」，才能支持任意切换机房，持续提供服务。</p><p>MySQL 本身就提供了双主架构，它支持双向复制数据，但平时用的并不多。而且 Redis、MongoDB 等数据库并没有提供这个功能，所以，你必须开发对应的「数据同步中间件」来实现双向同步的功能。</p><p>这样可能会带来数据冲突，数据没有在对方机房里同步时</p><p>一种方法：数据同步中间件要有自动「合并」数据、解决「冲突」的能力如依赖时钟，但这种方案需要两个机房的「时钟」严格保持一致才行，否则很容易出现问题</p><h3 id="如何实施异地双活"><a href="#如何实施异地双活" class="headerlink" title="如何实施异地双活"></a>如何实施异地双活</h3><p><strong>在最上层接入流量时，就不要让冲突的情况发生</strong> 避免跨机房 路由规则有三类</p><ol><li><p>按业务类型分片<br>假设我们一共有 4 个应用，北京和上海机房都部署这些应用。但应用 1、2 只在北京机房接入流量，在上海机房只是热备。应用 3、4 只在上海机房接入流量，在北京机房是热备。</p></li><li><p>直接哈希分片<br>这种方案就是，最上层的路由层，会根据用户 ID 计算「哈希」取模，然后从路由表中找到对应的机房，之后把请求转发到指定机房内。</p></li><li><p>按地理位置分片<br>这种方案，非常适合与地理位置密切相关的业务，例如打车、外卖服务就非常适合这种方案。<br>北京、河北地区的用户点餐，请求只会打到北京机房，而上海、浙江地区的用户，请求则只会打到上海机房。这样的分片规则，也能避免数据冲突。</p></li></ol><p><strong>让同一个用户的相关请求，只在一个机房内完成所有业务「闭环」，不再出现「跨机房」访问</strong></p><p>现在，两个机房就可以都接收「读写」流量（做好分片的请求），底层存储保持「双向」同步，两个机房都拥有全量数据，当任意机房故障时，另一个机房就可以「接管」全部流量，实现快速切换</p><p>不仅如此，因为机房部署在异地，我们还可以更细化地「优化」路由规则，让用户访问就近的机房，这样整个系统的性能也会大大提升。</p><h3 id="异地多活"><a href="#异地多活" class="headerlink" title="异地多活"></a>异地多活</h3><p>服务按照「单元化」的部署方式，可以让每个机房部署在任意地区，随时扩展新机房，你只需要在最上层定义好分片规则就好了。<br>但这里还有一个小问题，随着扩展的机房越来越多，当一个机房写入数据后，需要同步的机房也越来越多，这个实现复杂度会比较高。</p><p><img src="https://user-images.githubusercontent.com/58756074/138391560-2d8b5f9b-c729-455f-bea5-f224df6e7dd5.jpg" alt="异地多活"></p><p>这种方案必须设立一个「中心机房」，任意机房写入数据后，都只同步到中心机房，再由中心机房同步至其它机房，一个机房写入数据，只需要同步数据到中心机房即可，不需要再关心一共部署了多少个机房，实现复杂度大大「简化」。</p><p>但与此同时，这个中心机房的「稳定性」要求会比较高。不过也还好，即使中心机房发生故障，我们也可以把任意一个机房，提升为中心机房，继续按照之前的架构提供服务。</p><p><strong>可以任意扩展机房「就近」部署。任意机房发生故障，可以完成快速「切换」</strong></p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内核接收网络包</title>
    <link href="/2021/10/22/%E5%86%85%E6%A0%B8%E6%8E%A5%E6%94%B6%E7%BD%91%E7%BB%9C%E5%8C%85/"/>
    <url>/2021/10/22/%E5%86%85%E6%A0%B8%E6%8E%A5%E6%94%B6%E7%BD%91%E7%BB%9C%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="到达网卡"><a href="#到达网卡" class="headerlink" title="到达网卡"></a>到达网卡</h3><p>网卡接收网络包并存放在网卡内的缓冲区，实质上就是把网线中的高低电平，转换到网卡上的一个缓冲区中存储着</p><p>再由网卡缓冲区加载到内存缓冲区通过DMA，这个过程的前提是，<strong>网卡驱动</strong>需要在内存中申请一个缓冲区叫 <strong>sk_buffer</strong>，然后把这个 sk_buffer 的地址告诉网卡，这样 DMA 才知道等网卡的缓冲区有数据到来时，把它拷贝到内存的什么位置上。</p><h3 id="网卡发出中断（硬中断）"><a href="#网卡发出中断（硬中断）" class="headerlink" title="网卡发出中断（硬中断）"></a>网卡发出中断（硬中断）</h3><p>网卡向 CPU 发起中断信号，CPU 打断当前的程序，根据中断号找到中断处理程序，开始执行。<br>硬中断几乎啥也没干，将网卡设备 dev 放入 poll_list 里，然后立刻发起了一次软中断，然后就结束了。<br>这是为了尽快响应硬中断，以便计算机可以尽快处理下一个硬中断，毕竟鼠标点击、键盘敲击等需要响应特别及时。而像网络包到来后的拷贝和解析过程，在硬中断面前优先级没那么高，所以就触发一个软中断等着内核线程去执行就好了。</p><h3 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h3><p>软中断遍历 poll_list 取出一个个的设备 dev，然后调用其 poll 函数，移步IP网络层拿到IP包再交给上传传输层拿到TCP包解析出来的数据，由应用程序去接受和处理，就是我们的 socket bind listen read 的流程了</p><p>我们常说协议栈不断去掉头部，交给上层协议栈处理，这句话在代码层面其实就是网络层协议解析的方法 ip_rcv 里的末尾调用了传输层协议解析的方法 tcp_v4_rcv，仅此而已。</p><p>而说 Linux 处理中断是分上半部和下半部的方案，代码层面就是硬中断处理函数的代码里，直接发起一个软中断，然后便返回，仅此而已。</p><p><img src="https://user-images.githubusercontent.com/58756074/138385642-d9d7800a-e375-45fb-b4ab-4d6d7be9e052.png" alt="网络包到应用程序"></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中断</title>
    <link href="/2021/10/21/%E4%B8%AD%E6%96%AD/"/>
    <url>/2021/10/21/%E4%B8%AD%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>内核接收网络包的起点就是中断（硬中断和软中断）</p><h3 id="整个操作系统就是一个中断驱动的死循环"><a href="#整个操作系统就是一个中断驱动的死循环" class="headerlink" title="整个操作系统就是一个中断驱动的死循环"></a>整个操作系统就是一个中断驱动的死循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    doNothing();<br>&#125;<br></code></pre></td></tr></table></figure><p>其他所有事情都是由操作系统提前注册的中断机制和其对应的中断处理函数完成，我们点击一下鼠标，敲击一下键盘，执行一个程序，都是用中断的方式来通知操作系统帮我们处理这些事件，当没有任何需要操作系统处理的事件时，它就乖乖停在死循环里不出来。</p><h3 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h3><ul><li><p>中断 interrupts</p></li><li><p>异常 exception</p><ul><li>故障 faults</li><li>陷阱 traps</li><li>终止 aborts</li></ul></li></ul><p>CPU 提供了两种中断（verb）程序执行的机制，中断和异常。</p><p>先说第一个机制中断（interrupt），中断是一个异步事件，通常由 IO 设备触发。比如点击一下鼠标、敲击一下键盘等。</p><p>再说第二个机制异常（exception），异常是一个同步事件，是 CPU 在执行指令时检测到的反常条件。比如除法异常、错误指令异常，缺页异常等。</p><p>这两个机制，殊途同归，都是让 CPU 收到一个中断号</p><p>除上两种机制外，还有一种方式可以给到 CPU 一个中断号，INT指令（比如 INT 0x80，就是告诉 CPU 中断号是 0x80。Linux 内核提供的系统调用，就是用了 INT 0x80 这种指令）</p><p>有的地方喜欢把他们做一些区分，把 INT n 这种方式叫做软件中断，因为他是由软件程序主动触发的。相应的把上面的中断和异常叫做硬件中断，因为他们都是硬件自动触发的。</p><h3 id="给-CPU-一个中断号有三种方式"><a href="#给-CPU-一个中断号有三种方式" class="headerlink" title="给 CPU 一个中断号有三种方式"></a>给 CPU 一个中断号有三种方式</h3><ol><li><p><strong>通过中断控制器给 CPU 的 INTR 引脚发送信号</strong>，并且允许 CPU 从中断控制器的一个端口上读取中断号，比如按下键盘的一个按键，最终会给到 CPU 一个 0x21 中断号。</p></li><li><p><strong>CPU 执行某条指令发现了异常</strong>，会自己触发并给自己一个中断号，比如执行到了无效指令，CPU 会给自己一个 0x06 的中断号。</p></li><li><p><strong>执行 INT n 指令</strong>，会直接给 CPU 一个中断号 n，比如触发了 Linux 的系统调用，实际上就是执行了 INT 0x80 指令，那么 CPU 收到的就是一个 0x80 中断号。</p></li></ol><h3 id="CPU接收中断号后"><a href="#CPU接收中断号后" class="headerlink" title="CPU接收中断号后"></a>CPU接收中断号后</h3><p><strong>Roughly：CPU 收到一个中断号 n 后，会去中断向量表中寻找第 n 个中断描述符，从中断描述符中找到中断处理程序的地址，然后跳过去执行</strong></p><p>为什么说不准确这又涉及到操作系统的段式内存（段选因子+offset）通过段选因子找到段基址然后配合offset找到程序入口</p><ul><li><p>中断描述表（Interrupt Descriptor Table）就是一个在内存中的数组而已</p></li><li><p>中断描述符（desc_struct）就是中断描述符表这个数组里的存储的数据结构</p></li></ul><p>CPU通过IDTR寄存器找到IDT</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>现在这些都是硬中断（硬件完成的中断），当然这里也要有软件的配合，比如软件需要提前把中断向量表写在内存里，并通过 IDTR 寄存器告诉 CPU 它的起始位置在哪里。</p><p><strong>软中断是纯粹由软件实现的一种类似中断的机制</strong>，实际上它就是模仿硬件，在内存中有一个地方存储着软中断的标志位，然后由内核的一个线程不断轮询这些标志位，如果有哪个标志位有效，则再去另一个地方寻找这个软中断对应的中断处理程序。</p><h3 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h3><p>软中断是纯软件实现的，也是打断当前正在运行的程序，转而去执行中断处理程序，执行完之后再返回原程序。</p><p>硬中断的微观层面，就是 CPU 在每一个指令周期的最后，都会留一个 CPU 周期去查看是否有中断，如果有，就把中断号取出，去中断向量表中寻找中断处理程序，然后跳过去。</p><p>软中断的微观层面，简单说就是有一个<strong>单独的守护进程</strong>，不断轮询一组<strong>标志位</strong>，如果哪个标志位有值了，那去这个标志位对应的<strong>软中断向量表数组</strong>的相应位置，找到软中断处理函数，然后跳过去。</p><h3 id="开启内核软中断处理的守护进程"><a href="#开启内核软中断处理的守护进程" class="headerlink" title="开启内核软中断处理的守护进程"></a>开启内核软中断处理的守护进程</h3><p><img src="https://user-images.githubusercontent.com/58756074/138382715-f06ca2c9-5d4b-49ef-9cd0-0fcba5f78076.png" alt="Linux开机过程"></p><p>start_kernel: rest_init: 开启内核软中断守护进程</p><p>软中断向量表 softirq_vec，就是个数组嘛，然后里面的元素存储着软中断处理程序的地址指针</p><p><strong>不断遍历 pending 这个软中断标志位的每一位，如果是 0 就忽略，如果是 1，那从上面的 h 软中断向量表中找到对应的元素，然后执行 action 方法，action 就对应着不同的软中断处理函数</strong></p><h3 id="软中断两步走"><a href="#软中断两步走" class="headerlink" title="软中断两步走"></a>软中断两步走</h3><ol><li><p><strong>注册软中断向量表</strong>，其实就是把软中断向量表的每个 action 变量赋值，相当于硬中断中注册中断向量表的过程。<br>比如，<strong>网络子系统的初始化</strong>，有一步就需要<strong>注册网络的软中断处理函数</strong>。</p></li><li><p><strong>触发一个软中断</strong>，其实就是修改 pending 的某个标志位，触发一次软中断，相当于硬中断中由外部硬件、异常、或者 INT 指令来触发硬中断一样。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>软中断是 Linux 处理一个中断的下半部的主要方式</strong>，比如 Linux 某网卡接收了一个数据包，此时会触发一个硬中断，由于处理数据包的过程比较耗时，而硬中断资源又非常宝贵，如果占着硬中断函数不返回，会影响到其他硬中断的相应速度，比如点击鼠标、按下键盘等。</p><p>所以一般 Linux 会把中断分成**上下两半部分执行，上半部分处理最简单的逻辑，下半部分直接丢给一个软中断异步处理。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interrupt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown</title>
    <link href="/2021/10/20/Markdown/"/>
    <url>/2021/10/20/Markdown/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这是一级标题</span><br><span class="hljs-comment">## 这是二级标题</span><br><span class="hljs-comment">### 这是三级标题</span><br><span class="hljs-comment">#### 这是四级标题</span><br><span class="hljs-comment">##### 这是五级标题</span><br><span class="hljs-comment">###### 这是六级标题</span><br></code></pre></td></tr></table></figure><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">**这是加粗的文字**<br>*这是倾斜的文字*`<br>***这是斜体加粗的文字***<br>~~这是加删除线的文字~~<br></code></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;这是引用的内容<br>&gt;&gt;这是引用的内容<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容<br></code></pre></td></tr></table></figure><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">---<br>----<br>***<br>*****<br></code></pre></td></tr></table></figure><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">![图片alt](图片地址 <span class="hljs-string">&#x27;&#x27;</span>图片title<span class="hljs-string">&#x27;&#x27;</span>)<br><br>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。<br>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加<br></code></pre></td></tr></table></figure><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[超链接名](超链接地址 <span class="hljs-string">&quot;超链接title&quot;</span>)<br>title可加可不加<br></code></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">- 列表内容<br>+ 列表内容<br>* 列表内容<br><br>注意：- + * 跟内容之间都要有一个空格<br><br>1. 列表内容<br>2. 列表内容<br>3. 列表内容<br><br>注意：序号跟内容之间要有空格<br><br></code></pre></td></tr></table></figure><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">上一级和下一级之间敲三个空格即可<br>- 列表<br>   - 二级列表<br>   - 二级列表<br></code></pre></td></tr></table></figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">表头|表头|表头<br>---|:--:|---:<br>内容|内容|内容<br>内容|内容|内容<br><br>第二行分割表头和内容。<br>- 有一个就行，为了对齐，多加了几个<br>文字默认居左<br>-两边加：表示文字居中<br>-右边加：表示文字居右<br>注：原生的语法两边都要用 | 包起来。此处省略<br></code></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">单行     `代码内容`<br>(```)<br>  代码...<br>  代码...<br>  代码...<br>(```)<br>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。<br></code></pre></td></tr></table></figure><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">```flow<br>st=&gt;start: 开始<br>op=&gt;operation: My Operation<br>cond=&gt;condition: Yes or No?<br>e=&gt;end<br>st-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;op<br>&amp;`<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hosts File</title>
    <link href="/2021/10/20/Hosts-File/"/>
    <url>/2021/10/20/Hosts-File/</url>
    
    <content type="html"><![CDATA[<p>Hosts file是将域名和IP建立mapping，相当于DNS缓存，浏览器会先优先在hosts里查找IP，如果没有则系统再将网址提交DNS域名解析服务器进行解析</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="TBA"><a href="#TBA" class="headerlink" title="TBA"></a>TBA</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /etc<br>$ vim hosts<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hosts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Two Git Accounts On One Device</title>
    <link href="/2021/10/20/Two-Git-Accounts-On-One-Device/"/>
    <url>/2021/10/20/Two-Git-Accounts-On-One-Device/</url>
    
    <content type="html"><![CDATA[<p>This blog will discuss how to maintain two github accounts on one device.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Generate-SSH-keys"><a href="#Generate-SSH-keys" class="headerlink" title="Generate SSH keys"></a>Generate SSH keys</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;email address&quot;</span><br></code></pre></td></tr></table></figure><p>Note:</p><p>-b specify the size of keyfile “bits”</p><p>-t means type should usually be rsa , dsa , ecdsa</p><p>-c means comment Changes the comment for the keyfile</p><h3 id="Register-pub-key-to-github"><a href="#Register-pub-key-to-github" class="headerlink" title="Register pub key to github"></a>Register pub key to github</h3><p>skip (Settings/SSH and GPG)</p><h3 id="Create-a-config-file-at-ssh"><a href="#Create-a-config-file-at-ssh" class="headerlink" title="Create a config file at ~/.ssh"></a>Create a config file at ~/.ssh</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># tw(xiang.li4@thoughtworks.com)</span><br>Host github.com-LiXiang-TW<br>   HostName github.com<br>   User git<br>   IdentityFile ~/.ssh/id_rsa.tw<br>   IdentitiesOnly yes<br><br><span class="hljs-comment"># me(xili7209@gmail.com)</span><br>Host github.com-xili7209<br>   HostName github.com<br>   User git<br>   IdentityFile ~/.ssh/id_rsa.me<br>   IdentitiesOnly yes<br><br></code></pre></td></tr></table></figure><h3 id="Clone-the-repo-replace-github-com-with-github-com-xili7209-LiXiang-TW"><a href="#Clone-the-repo-replace-github-com-with-github-com-xili7209-LiXiang-TW" class="headerlink" title="Clone the repo (replace github.com with github.com-xili7209/LiXiang-TW)"></a>Clone the repo (replace github.com with github.com-xili7209/LiXiang-TW)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> git@github.com-GitId:GitId/your-repo-name.git (your-repo-name_GitId)<br></code></pre></td></tr></table></figure><h3 id="Configure-git-identity"><a href="#Configure-git-identity" class="headerlink" title="Configure git identity"></a>Configure git identity</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[user]<br>    name = git name<br>    email = ***@gmail.com<br></code></pre></td></tr></table></figure><h3 id="Ensure-reomte-url-is-git-remote-set-url-origin-x67-105-116-64-103-x69-116-x68-117-x62-x2e-99-111-109-45-x67-x69-116-78-x61-x6d-x65-gitName-your-repo-name-git-your-repo-name-gitName"><a href="#Ensure-reomte-url-is-git-remote-set-url-origin-x67-105-116-64-103-x69-116-x68-117-x62-x2e-99-111-109-45-x67-x69-116-78-x61-x6d-x65-gitName-your-repo-name-git-your-repo-name-gitName" class="headerlink" title="Ensure reomte url is git remote set-url origin &#x67;&#105;&#116;&#64;&#103;&#x69;&#116;&#x68;&#117;&#x62;&#x2e;&#99;&#111;&#109;&#45;&#x67;&#x69;&#116;&#78;&#x61;&#x6d;&#x65;:gitName/your-repo-name.git (your-repo-name_gitName)"></a>Ensure reomte url is <strong>git remote set-url origin <a href="mailto:&#x67;&#105;&#116;&#64;&#103;&#x69;&#116;&#x68;&#117;&#x62;&#x2e;&#99;&#111;&#109;&#45;&#x67;&#x69;&#116;&#78;&#x61;&#x6d;&#x65;">&#x67;&#105;&#116;&#64;&#103;&#x69;&#116;&#x68;&#117;&#x62;&#x2e;&#99;&#111;&#109;&#45;&#x67;&#x69;&#116;&#78;&#x61;&#x6d;&#x65;</a>:gitName/your-repo-name.git (your-repo-name_gitName)</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[remote <span class="hljs-string">&quot;origin&quot;</span>] <br>       url = git@github.com-gitName:gitName/your-repo-name.git<br>       fetch = +refs/heads/*:refs/remotes/origin/*<br></code></pre></td></tr></table></figure><p>More info: <a href="https://gist.github.com/Jonalogy/54091c98946cfe4f8cdab2bea79430f9">Handle_Multi_GitAccount</a></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Terminal-ShortCut</title>
    <link href="/2021/10/20/Terminal-ShortCut/"/>
    <url>/2021/10/20/Terminal-ShortCut/</url>
    
    <content type="html"><![CDATA[<p>终端快捷键</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash">Ctrl+a：光标回到命令行首。 （a：ahead）<br><br>Ctrl+a：光标回到命令行首。 （a：ahead）<br><br>Ctrl+e：光标回到命令行尾。 （e：end）<br><br>Ctrl+b：光标向行首移动一个字符。 （b：backwards）<br><br>Ctrl+ f：光标向行尾移动一个字符。 （f：forwards）<br><br>Ctrl+w: 删除光标处到行首的字符。<br><br>Ctrl+k：删除光标处到行尾的字符。<br><br>Ctrl+u：删除整个命令行文本字符。<br><br>Ctrl+h：向行首删除一个字符。<br><br>Ctrl+d：向行尾删除一个字符。<br><br>Ctrl+y:：粘贴Ctrl+u，Ctrl+k，Ctrl+w删除的文本。<br><br>Ctrl+p: 上一个使用的历史命令。 （p：previous）<br><br>Ctrl+n： 下一个使用的历史命令。（n：next ）<br><br>Ctrl+r：快速检索历史命令。（r：retrieve）。<br><br>Ctrl+t： 交换光标所在字符和其前的字符。<br><br>Ctrl+i：相当于Tab键。<br><br>Ctrl+o：相当于Ctrl+m.<br><br>Ctrl+m：相当Enter键。<br></code></pre></td></tr></table></figure><h3 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">Ctrl+s:使终端发呆，静止，可以使快速输出的终端屏幕停下来。<br><br>Ctrl+q：退出Ctrl+s引起的发呆。<br><br>Ctrl+z：使正在运行在终端的任务，运行于后台。 （可用<span class="hljs-built_in">fg</span>恢复）<br><br>Ctrl+c：中断终端中正在执行的任务。<br><br>Ctrl+d: 在空命令行的情况下可以退出终端。<br><br>Ctrl+[ ：相当于Esc键。<br><br>Esc键：连续按3次显示所有的支持的终端命令。<br><br>Tab键：命令、文件名等自动补全功能。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shortcut</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/10/20/hello-world/"/>
    <url>/2021/10/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate  <span class="hljs-comment">#hexo g</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy  <span class="hljs-comment">#hexo d</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="Hexo-Clean-amp-amp-Hexo-Deploy"><a href="#Hexo-Clean-amp-amp-Hexo-Deploy" class="headerlink" title="Hexo Clean &amp;&amp; Hexo Deploy"></a>Hexo Clean &amp;&amp; Hexo Deploy</h3><p>Note: 部署需要注意congfig.yml里deploy下仓库格式：<a href="mailto:&#x67;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#104;&#117;&#x62;&#46;&#x63;&#111;&#x6d;">&#x67;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#104;&#117;&#x62;&#46;&#x63;&#111;&#x6d;</a>:liuxianan/liuxianan.github.io.git（不要用https）</p><h3 id="注意front-matter（—）页面格式内容应该在front-matter内编辑"><a href="#注意front-matter（—）页面格式内容应该在front-matter内编辑" class="headerlink" title="注意front matter（—）页面格式内容应该在front matter内编辑"></a>注意front matter（—）页面格式内容应该在front matter内编辑</h3>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
